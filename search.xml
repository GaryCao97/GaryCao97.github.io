<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Oracle学习笔记——基础篇]]></title>
    <url>%2F2019%2F07%2F10%2FOracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[培训第二课，Oracle。 第一讲 关系数据库概述数据库简介数据库数据库是按照数据结构来组织、存储和管理数据的仓库目前按照发展事件可分为两类：1.现代数据模型：最经典的就是面向对象模型2.传统的数据模型：包括层次模型、网状模型和关系模型三种。 层次模型：用树形结构自顶向下表示实体和实体间1:n联系 网状模型：用网状图形结构表示实体和实体间的m:n联系，网中结点之间的联系不受层次限制 关系模型：用二维表格的形式来表示实体和实体间联系 数据库管理系统数据库管理系统(Database Management System)是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS。它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。用户通过DBMS访问数据库中的数据，数据库管理员也通过DBMS进行数据库的维护工作。它可使多个应用程序和用户用不同的方法在同时或不同时刻去建立，修改和询问数据库。大部分DBMS提供数据定义语言DDL（Data Definition Language）和数据操作语言DML（Data Manipulation Language），供用户定义数据库的模式结构与权限约束，实现对数据的追加、删除等操作。 数据库层次结构硬件 - 操作系统 - 数据库、数据库管理系统 - 数据库应用系统 - 用户 用户指与数据库系统打交道的人员，包括三类人员：最终用户、数据库应用系统开发员、数据库管理员。 数据库应用系统指为满足用户需求、采用各种应用开发工具（Java、C++、PB、Delphi等）和开发技术开发的数据库应用软件。 数据库是存储在计算机上的、可共享的、有组织的、长期的、大量的数据的集合。 数据库管理系统是位于操作系统和关系型数据库应用系统之间的数据库管理软件。 关系数据库关系数据库，是建立在关系数据库模型基础上的数据库，借助于集合代数等概念和方法来处理数据库中的数据，同时也是一个被组织成一组拥有正式描述性的表格，该形式的表格作用的实质是装载着数据项的特殊收集体，这些表格中的数据能以许多不同的方式被存取或重新召集而不需要重新组织数据库表格。关系数据库的定义造成元数据的一张表格或造成表格、列、范围和约束的正式描述。每个表格（有时被称为一个关系）包含用列表示的一个或更多的数据种类。 每行包含一个唯一的数据实体，这些数据是被列定义的种类。当创造一个关系数据库的时候，你能定义数据列的可能值的范围和可能应用于那个数据值的进一步约束。而SQL语言是标准用户和应用程序到关系数据库的接口。其优势是容易扩充，且在最初的数据库创造之后，一个新的数据种类能被添加而不需要修改所有的现有应用软件。主流的关系数据库有oracle、db2、sqlserver、sybase、mysql等。 目前关系数据库是数据库应用的主流，许多数据库管理系统的数据模型都是基于关系数据模型开发的。1）关系数据库：在一个给定的应用领域中，所有实体及实体之间联系的集合构成一个关系数据库。2）关系数据库的型与值：关系数据库的型称为关系数据库模式，是对关系数据库的描述，若干域的定义，在这些域上定义的若干关系模式；关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常简称为关系数据库。关系数据库分为两类：一类是桌面数据库，例如Access、FoxPro和dBase等；另一类是客户/服务器数据库，例如SQL Server、Oracle和Sybase等。一般而言，桌面数据库用于小型的、单机的应用程序，它不需要网络和服务器，实现起来比较方便，但它只提供数据的存取功能。客户/服务器数据库主要适用于大型的、多用户的数据库管理系统，应用程序包括两部分：一部分驻留在客户机上，用于向用户显示信息及实现与用户的交互；另一部分驻留在服务器中，主要用来实现对数据库的操作和对数据的计算处理。 关系数据库就是以关系作为数据模型，对数据进行组织和管理的数据库系统模型中以二维表的形式来描述数据对于每个二维表，我们有一些限制条件，每个属性列有唯一的名称、属性的次序无所谓、元组的次序无所谓、每个属性中的数据必须具有相同的数据类型。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记——入职篇]]></title>
    <url>%2F2019%2F07%2F04%2FJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%A5%E8%81%8C%E7%AF%87%2F</url>
    <content type="text"><![CDATA[培训第一课，Java。 课程目标熟练掌握Java语言，学会用Java编写代码掌握面向对象在编程中的应用熟练掌握异常的处理机制熟练运用Java完成开发任务熟练使用开发工具编写，调试和运行程序 第一讲 认识Java本讲目标 认识JAVA技术 了解JAVA语言的主要特点 掌握开发环境配置 熟练使用MyEclipse编写并运行代码 Java的主要特点 简单：语法与C和C++类似 面向对象：类、对象；封装、继承、多态 健壮：异常处理、垃圾回收、无指针 与平台无关：通过二进制字节码(.class)和Java虚拟机(JVM)实现 Java安装与配置官网下载JDK(Java开发工具包)，包含开发环境和运行环境，然后按照安装提示一步步进行。 环境变量配置位置：右击“我的电脑”-&gt;“属性”项 -&gt; “高级系统设置” -&gt;“环境变量” 环境变量名 变量值 JAVA_HOME 安装的JDK的位置 CLASSPATH Java工具库的位置 Path Java编译工具位置 测试配置打开命令提示行，输入java --version或者javac --version，按回车键，若能正常显示JDK的版本信息，就表明JDK已经安装和配置完成。 Java开发过程 Java开发的基本规则 Java源文件必须以”.java”为扩展名。源文件的基本组成部分是类(class)，class 关键字后面的即类名，如本例中的HelloWorld类。 一个源文件中最多只能有一个public类，其他类的个数不限。如果源文件包含一个public类，则必须以类名命名源文件。 Java应用程序的执行入口是main()方法，它有固定的书写格式。 Java严格区分大小写。 每条Java语句由分号结束。123public static void main(String [] args)&#123; //main方法主体&#125; 第二讲 Java语言概述本讲目标 掌握java语言的基本元素 掌握程序的控制流程 掌握java程序的组织结构 掌握数组的使用 Java语言基本元素1. 标识符标识符是用来给类、对象、方法、变量、接口和自定义数据类型命名的。定义规则以英文大小写字母、下划线“_”、或“$”开始的一个字符序列。数字不能作为标识符的第1个字符。标识符不能是Java的关键词。标识符大小写敏感且长度没有限制。 2. 关键字关键字是程序里事先定义的，有特别意义的标识符，有时又叫保留字，不能当作一般的标识符使用。 abstractcontinuegotonullswitchassertdefaultifpackagesynchronizedbooleandoimplementsprivatethisbreakdoubleimportprotectedthrowbyteelseinstanceofpublicthrowscaseextendsintreturntransientcatchfinalinterfaceshorttrycharfinallylongstaticvoidclassfloatnativestrictfpvolatileconstfornewsuperwhile 3. 变量是指在程序的运行过程中随时可以发生变化的量，是程序中数据的临时存放场所。定义变量的语法规则为： 变量数据类型 变量名 [ = 变量初值] ;若要同时声明多个相同数据类型的变量，可以分别声明它们，也可以把它们都写在同一个语句中，每个变量之间以逗号分开，如下面的写法： 变量数据类型 变量名1[ = 变量初值1] ，变量名2 [ = 变量初值2]，变量名3 [ = 变量初值3]; 4. 常量指程序里持续不变的值，在整个程序运行过程中它是不可改变的。例如整数常量、字符串常量。Java中用关键字final来声明常量，并且必须声明它所预保存的数据类型。 5. 数据类型graph LR A[数据类型] --> B[基本类型] A --> C[引用类型] B --> D[数值型] B --> E[字符型] B --> F[布尔型] C --> G[类] C --> H[接口] C --> I[数组] D --> J[整数类型] D --> K[浮点类型] boolean（逻辑型） 只有两种取值true or false，占用一个字节。byte(字节类型) 一个byte 8位，占用1个字节（-128~127）short(短整型) 一个short 16位，占用2个字节（-32768~32767）int(整型)一个int 32位，占用4个字节（-2147483648~2147483647）long(长整型) 一个long 64位占用8个字节（-2^63~2^63-1）char(字符型) 一个char16位，占用2个字节，用于表示字符。float（单精度浮点型） 一个float 32位，占用4个字节（-3.4E38 ~3.4E38）double(双精度浮点型) 一个double 64位，占用8个字节 （-1.7E308 ~1.7E308） 整数类型（byte、short、int默认、long）1、Java各整数类型有固定的表数范围和字段长度，其不受操作系统的影响，以保证Java程序的可移植性。2、Java语言的整形常量默认为int型，声明long型后面需加上l或者L，否则会出错。 浮点数类型（float、double默认）1、与整数类型相似，Java浮点数类型有固定的表数范围和字段长度，不受平台影响。2、Java浮点型常量默认为double型，如要声明一个常量为float型，则需在数字后面加f或F，否则出错。 字符类型（char）char类型的值通常用单引号(‘和’)括起来。例如：&#39;a&#39;、&#39;中&#39;、&#39;\n&#39;、&#39;\u03A6&#39; 布尔类型（boolean）boolean类型适于逻辑运算且只有两个值：true 和 false 自动类型转换（隐式类型转换）有多种类型的数据混合运算时，系统首先自动的将所有数据转换成容量最大的那一种数据类型，然后进行计算。boolean类型不可以转换为其他的数据类型。整型、字符型、浮点型的数据在混合运算中相互转换，转换时遵守以下原则：byte、short、char之间不会相互转换，他们三者在计算时首先会转换为int类型。得到的计算结果为int类型。 强制类型转换（显式类型转换）容量大的数据类型转换为容量小的数据类型时，需要使用强制类型转换，其格式如下： 12int b = 1; byte a = (byte)b; 在强制类型转换过程中，源类型的值可能大于目标类型，因此可能造成精度降低或溢出，使用时需注意。 浮点数当两个整数相除时，小数点以后的数字会被截断，使得运算的结果保持为整数。想要得到运算的结果为浮点数，就必须将两个整数中的其中一个（或是两个）强制转换类型为浮点数只要在变量前面加上欲转换的数据类型，运行时就会自动将此行语句里的变量做类型转换的处理，但这并不影响原先所定义的数据类型。 6.运算符程序是由许多语句组成的，而语句的基本单位是表达式与运算符。每个语句结束时，必须以分号“ ;”做结尾。表达式是由操作数与运算符所组成：操作数可以是常量、变量也可以是方法，而运算符可以是数学运算符、逻辑运算符、地址运算符等。以下面的表达式（ z+100）为例，“ z”与“ 100”都是操作数，而“ +”就是运算符。 按操作数的数目分：一元运算符：++ --二元运算符：+ - &lt; &gt; =三元运算符：?: 按功能分：算术运算符：+，-，*，/，%，++，--关系运算符：&gt;，&gt;=，&lt;，&lt;=，==，!=逻辑运算符：!，&amp;&amp;，||赋值运算符：=，+=，-=，*=，/=条件运算符：?: 运算符的优先次序1) ()2) ++ , -- , !3) * , / , %4) + , -5) &gt; , &lt; , &gt;= , &lt;=6) == , !=7) &amp;8) |9) &amp;&amp;10) ||11) ?:12) = , += ，-= 自加(++)、自减(–)运算符++(–)在前时先运算再取值++(–)在后时先取值再运算 1234int i=0;int j=i++ + ++i;int k=--i + i--;System.out.println(“j=” + j + ”,k=” + k); 结果为j=2,k=2 7.代码注释 // 注释一行 /* 注释多行 */ /** 文档注释 */ 其中，用文档注释（/**……*/）的注释内容会被解释成程序的正式文档，并能包含进如 javadoc之类的工具生成的文档里，用以说明该程序的层次结构及其方法 控制语句顺序结构程序至上而下逐行执行，一条语句执行完之后继续执行下一条语句，一直到程序的末尾。 graph TD A(开始) --> B[语句1] B --> C[语句n] C --> D(结束) 选择结构根据条件的成立与否，再决定要执行哪些语句的结构。 graph TD A(开始) --> B{判断条件} B -->|True| C[语句1] B -->|False| D[语句2] C --> E[语句3] D --> E E --> F(结束) 代码大体如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445if (判断条件) &#123; 语句 1 ； 语句 2 ； … 语句 n ；&#125;orif (判断条件)&#123; 语句主体 1 ；&#125;else&#123; 语句主体 2； &#125;orif (条件判断 1)&#123; 语句主体 1;&#125; else if (条件判断 2)&#123; 语句主体 2;&#125;… // 多个 else if()语句else&#123; 语句主体 3;&#125;orswitch (表达式)&#123; case 选择值 1: 语句主体 1; break; case 选择值 2: 语句主体 2; break; ……. case 选择值 n: 语句主体 n; break; default: 语句主体;&#125; switch表达式的返回值类型必须是int、byte、char、short中的一种。case子句中的值value必须是常量，而且所有case子句中的值应是不同的。default子句是可选的。break语句用来在执行完一个case分支后，使程序跳出switch语句，即终止switch语句的执行。 循环结构根据判断条件的成立与否，决定程序段落的执行次数，而这个程序段落就称为循环主体。 graph TD A(开始) --> B{判断条件} B -->|True| C[语句1] B -->|False| D[语句2] C --> B[语句3] D --> E(结束) 代码大体如下： 1234567891011121314151617181920212223for (赋值初值; 判断条件; 赋值增减量)&#123; 语句 1; …. 语句 n;&#125;orwhile (判断条件)&#123; 语句 1; 语句 2; … 语句 n;&#125;ordo&#123; 语句 1; 语句 2; …. 语句 n;&#125; while (判断条件) 当循环语句中又出现循环语句时，就称为嵌套循环。如嵌套 for 循环、嵌套 while循环等，当然读者也可以使用混合嵌套循环，也就是循环中又有其他不同种类的循环。 关键词 break离开当前层的循环主体，继续执行循环外的语句 continue跳出本次循环，回到循环起点，继续执行下一次循环 return从被调函数返回到主调函数继续执行 程序结构包 命名程序中使用package语句来声明包。package 包名; 规则： package语句作为Java源文件的第一条语句，指明该源文件定义的类所在的包。 包名可以是一个合法的标识符，也可以是若干个标识符加“.“分割而成。 如果一个类有包名，那么存储文件的目录中必须包含有相应的结构。 包语句程序如果使用了包语句，例如：package com.dareway.codec;那么存储文件的目录中必须包含有如下的结构：…\com\dareway\codec 如果在源程序中用到了除java.lang这个包以外的类，并且引用的类与源程序不在同一个包中，那么无论是系统的类还是自己定义的包中的类，都必须用import语句标识，以通知编译器在编译时找到相应的类文件。 类 命名：Java 程序是由类（class）所组成。 123public class HelloWorld &#123; // 类声明 …&#125; 规则：在完整的 Java 程序里，至少需要有一个类。public修饰的类所在的原始程序的文件名不能随意命名，必须和 public 类名称一样。在一个独立的原始程序里，只能有一个 public 类，可以有许多非public 类。 大括号、段、主体 左大括号“ {”为主体开始的标记，至右大括号“ }”结束。 类和方法的主体要通过大括号进行标记。 每个命令语句结束时，必须以分号“ ;”做结尾。 当某个命令的语句不只一行时，必须以一对大括号“ {}”将这些语句包括起来，形成一个程序段（segment）或是块（block）。 在使用选择结构或是循环结构时，需要使用大括号将分支语句或是循环主体包括起来。 方法12345[访问控制符] [修饰符] 返回值类型 方法名称（类型 参数 1，类型 参数 2， …）&#123; 程序语句 ； return 表达式；&#125; 如果不需要传递参数到方法中，只需要将方法名称后面的()写出，不必填入任何内容。如果方法没有返回值，则 return 语句可以省略，并且返回值类型应该为void main方法main()方法为程序的主方法，在一个Java应用程序中有且只能有一个 main()方法，它是程序运行的开端，有固定的格式，如下所示： 1234public static void main(String args[]) // 主程序入口 &#123; …&#125; 一维数组声明数组 格式 类型名[] 数组名; 类型名 数组名[]; 示例 int[] a，b；//等价于 int a[],b[]； int a[]，b；//此处的b不是数组类型 float[] a = new float[10]； float a[10]; //格式非法 创建数组 格式： 数组名 = new 类型名[长度]； 举例 a = new int[20]； float[] f = new float[100]； 数组初始化 格式： 数组类型 数组名[] = {元素1，元素2，…} 数组类型 数组名[] = new 数据类型[]{元素1，元素2，…} 示例： int a[] = {1,2,3,4,5}; int[] b = new int[] { 1, 2, 3, 4, 5 }; 数组访问 格式： 数组名[下标值] 数组的下标值从0开始计 每个数组都有一个属性length指明数组长度，即元素个数，格式：数组名.length 示例：12345int[] a = new int[]&#123;1,2,3,4,5&#125;;for(int i=0; i&lt;a.length; i++)&#123; a[i]=a[i]+1; System.out.print(a[i]+", ");&#125; 多维数组声明数组 格式 数组类型 数组名[][] 数组类型[][] 数组名; 数组类型[] 数组名[]; 示例 int a[][]; int[][] b; int[] c[]; 特性 Java中没有真正的多维数组，只有数组的数组。 Java中多维数组不一定是规则矩阵形式。 创建数组 格式： 数组名 = new 数据元素类型[行数] [列数] ; 数组名 = new 数据元素类型[行数] [] ; 举例 int a[][] = new int[3][4]; int[][] b = new int[3][]; int[] c[] = newint[][4]; // 非法，必须声明行的个数 数组初始化 格式： 数组类型 数组名[][] = { {元素11，元素12，…} , {元素21，元素22，… } } 数组类型 数组名[][] = new 数据类型[][] { {元素11，元素12，…} , {元素21，… } } 示例： int a[][] = { {1,2,3}, {4,5}, {7} }; int b[][] = new int[][]{ {1,2,3}, {4,5}, {7} }; 第三讲 面向对象基础第四讲 常用类库介绍第五讲 断点调试第六讲 Java异常处理]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秋招笔试(更新中)]]></title>
    <url>%2F2018%2F10%2F15%2F%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95-%E6%9B%B4%E6%96%B0%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[秋招进行中，记录我的笔试编程题目。 多益网络题目：不使用递归，实现二叉树的后序遍历算法思想：从根开始然后依次将左节点入栈当到达该树最左时，输出此节点、出栈此节点并开始将栈中的节点的右子树入栈，然后重复上述过程直到栈空代码： 吉比特1.指数幂求模题目：求 $a^p \mod b$ 的结果输入：$a&lt;10000 , p&lt;10000000000 , b&lt;10000$ 19 5 33 输出： 112 算法思想：代码： 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int PowMod(int n, long long p,int M)&#123; int ans = 1; while (p &gt; 0) &#123; if (p % 2 == 1)&#123; ans = (ans*n) % M; &#125; p /= 2; n = (n*n) % M; &#125; return ans;&#125;int main() &#123; int a,mod; long long b; cin &gt;&gt; a &gt;&gt; b &gt;&gt; mod; cout &lt;&lt; PowMod(a,b,mod); return 0;&#125; 2.摊位问题题目：学校摆摊，已知摊位能拜访的所有位置，两摊位之间不能相邻（斜着不算），总共有多少种摆摊方法输入：第一行确定矩阵大小$n*m$，接下来给出矩阵元素，1表示可以摆摊，0表示不能摆摊 1232 31 1 10 1 0 输出：实际结果对987654321取余 19 算法思想：代码：]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态网页基础之JSP]]></title>
    <url>%2F2018%2F06%2F28%2F%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80%E4%B9%8BJSP%2F</url>
    <content type="text"><![CDATA[JSP开发环境的配置运行 （一）JDK安装与配置1．安装JDK运行下载的JDK软件包，可安装SDK，在安装过程中可以设置安装路径及选择组件，系统默认的安装路径为C:\ jdk1.5(当然也可以自己设定)，默认的组件选择是全部安装。 2．JDK环境变量的配置第一步：进入系统属性选择高级属性。第二步： 进入环境变量界面。第三步： 添加环境变量值。第四步：添加PATH路径 C:\jdk1.5\bin(即JDK安装目录下的bin目录) （二）Tomcat安装与配置1．安装Tomcat运行下载的Tomcat软件包，可安装SDK，在安装过程中可以设置安装路径及选择组件，安装路径为C:\Tomcat5，默认的组件选择是全部安装。 2．Tomcat环境变量的配置第一步：进入系统属性选择高级属性。第二步：进入环境变量界面。第三步：添加环境变量值。第四步：添加PATH路径 C:\Tomcat5.0\bin （三）Eclipse的安装与配置1．安装Eclipse 先解压eclipse-SDK-3.2.1-win32.zip文件，然后运行MyEclipseEnterpriseWorkbenchInstaller_5.0.1GA_E3.2.exe软件。并选择安装路径，当安装提示要选择Eclipse SDK时，选择已经解压好的eclipse文件目录，然后照提示完成安装。 2．Eclipse的环境配置 先运行MyEclipse 5.0GA软件，第一次运行时需要建立一个工程文件目录，这里根据个人习惯自行建立。进入Eclipse界面后：第一步：选择windows菜单选择Preferences项。第二步：进入Preferences界面在type filter text中选择MyEclipse再选Application Server再选择Tomcat 5。后面操作如下图，分别选择Tomcat的安装路径，并选择Enable激活。第三步：配置JDK。点开Tomcat，选择JDK。并点add。第四步：添加JDK。在“JRE name：”写上JRE的名称（可以任意命名），在“JRE home directory”栏点browse选择JDK的安装路径。然后点确定，最后点击完成。第五步：测试安装是否成功。检测是否能启动Tomcat。 （四）在Eclipse上建立一个JSP1．建立一个新的工程文件，名为exam1。 2．建立一个JSP，名为First.jsp 3． 编写JSP程序。在First.jsp中编写： 123&lt;body&gt; hello! This is my the First JSP page. &lt;br&gt;&lt;/body&gt; （五）部署JSP工程文件1．进入开部署界面点击 2．部署：在Project中选择要部署的工程文件，再点add。 （六）启动Tomcat服务器 （七）浏览JSP打开浏览起，在地址栏输入：http://localhost:8080/exam1/First.jsp 。 JSP Servlet技术 Web应用程序有严格定义的目录结构，它需要一个称为部署描述文件的文件web.xml来配置。对应用程序的每个Servlet，可以在web.xml中定义若干个初始化参数，然后通过ServletConfig对象获取这些参数。 ServletContext对象表示该应用程序的环境，通过该对象可以获得应用程序范围的初始化参数、容器版本信息、资源的URL、在其中存放共享数据以及登录日志等。 Servlet事件监听 在Web应用程序中，事件的处理也是通过事件监听器接口处理的。Web应用事件处理的原理为：当Web应用中某些状态改变时，Servlet容器就产生某种事件，如ServletContext对象初始化时会产生ServletContextEvent事件，此时Servlet容器就会从注册的事件监听器中寻找处理该事件的监听器对象，并执行相应的代码。 在Servlet 2.4规范中共定义了6种事件类型和8个事件监听器接口，它们可以处理三种对象上的事件，如下表所示： 监听对象监听器接口监听事件 ServletContextServletContextListenerServletContextEvent ServletContextAttributeListenerServletContextAttributeEvent HttpSessionHttpSessionListenerHttpSessionEvent HttpSessionActivationListener HttpSessionAttributeListenerHttpSessionBindingEvent HttpSessionBindingListener ServletRequestServletRequestListenerServletRequestEvent ServletRequestAttributeListenerServletRequestAttributeEvent Servlet过滤器的使用 过滤器是web服务器上的组件，它们对客户和资源之间的请求和响应进行过滤。 过滤器的工作原理是：当servlet容器接收到对某个资源的请求，它要检查是否有过滤器与之关联。如果有过滤器与该资源关联，servlet容器将把该请求发送给过滤器。在过滤器处理完请求后，它将做下面3件事： 产生响应并将其返回给客户； 如果有过滤器链，它将把（修改过或没有修改过）请求传递给下一个过滤器； 将请求传递给不同的资源。 当请求返回到客户时，它是以相反的方向经过同一组过滤器返回。过滤器链中的每个过滤器够可能修改响应。过滤器API主要包括：Filter、FilterConfig和FilterChain接口。 JSP 会话管理 HTTP协议是无状态的协议。在很多情况下，Web服务器必须能够跟踪客户的状态。比如，对于一个购物网站，在一个时刻可能有多个客户购物，Web服务器必须能够区分不同的客户。一般情况下，Web服务器为每个客户配置了虚拟的购物车（ShoppingCart）。当某个客户请求将一个商品放入购物车时，Web服务器必须根据发出请求的客户的身份，找到该客户的购物车，然后把商品放入其中。 Web服务器跟踪客户的状态通常有4种方法：（1）使用HttpSession对象管理会话；（2）使用持久的Cookie对象；（3）使用URL重写机制；（4）使用隐藏的表单域。 JSP基本语法与页面指令 JSP语法元素有&lt;% %&gt;、&lt;%@ %&gt;、&lt;%= %&gt;和&lt;%! %&gt;四种，分别是运行Java代码、jsp的初始化以及导入、输出java表达式的值和java初始化代码 JSP有三个指令元素：page、include和taglib。这些指令元素是针对JSP引擎的，并不会产生任何看得见的输出。它们都包含在&lt;%@和%&gt;标签内。主要学会使用page指令。 &lt;%@ page %&gt;指令作用于整个JSP页面，包括静态包含的页面，但不包括动态包含的页面。可以在一个页面中包含多个&lt;%@ page %&gt;指令，但其属性除import外只能在整个页面中出现一次。&lt;%@ page %&gt;指令可以放在页面的任何位置，但为了JSP程序的可读性，一般将&lt;%@ page %&gt;指令放在页面的前面。&lt;%@ page %&gt;主要包含以下几种基本属性：1）import、引用类文件；2）language，指定脚本语言；3）contentType，指定jsp编码方式； JSP隐含对象与作用域 在JSP页面的转换阶段（JSP页面转换后定义的类名为：implicit_jsp，该类继承了org.apache.jasper.runtime.HttpJspBase），JSP引擎在_jspService()方法中声明并初始化了9个隐含对象，它们主要是为了方便在JSP页面对这些对象的访问。这些隐含对象包括：application、session、request、response、out、page、pageContext、config、exception。 在上述9个隐含对象中，有下面4个作用域对象，它们是：application、session、request、pageContext。它们主要用来在不同作用域中共享数据。 一）request对象request对象是javax.servlet.http.HttpServletRequest对象的一个实例。每次客户端请求一个页面时，JSP引擎都会创建一个新的对象来表示那个请求。request对象提供方法来获取HTTP头信息，包括表单数据，cookies，HTTP方法等。 二）response对象response对象是javax.servlet.http.HttpServletResponse对象的一个实例。当服务器创建request对象时，它也创建了代表客户端响应的对象。response对象还定义了接口，可以处理创建的新的HTTP 头。通过这个对象JSP程序员可以添加新的cookies或日期stamps，HTTP状态码等。 三）out对象out隐式对象是javax.servlet.jsp. JspWriter对象的一个实例，用于在响应中发送内容，在Servlet中可以通过pageContext.getOut()来获取该对象。最初的JspWriter对象被实例化不同程度地取决于页面是否缓冲。通过使用页面指令的buffered=&#39;false&#39;属性，缓冲可以很容易地关掉。JspWriter对象包含大部分与java.io.PrintWriter类相同的方法。然而，JspWriter对象有一些额外的方法用来处理缓冲。与PrintWriter对象不同，JspWriter抛出IOException。 四）session对象session对象是javax.servlet.http.HttpSession的一个实例，且行为与Java Servlet中的session对象完全相同，在Servlet中可以通过pageContext.getSession()来获取该对象。session对象是用来跟踪客户端请求之间的客户端会话。 五）application对象application对象是用于生成的Servlet的ServletContext对象的直接包装器，且实际上是javax.servlet.ServletContext对象的一个实例，在Servlet中可以通过pageContext.getServletContext()来获取该对象。这个对象是JSP页面整个生命周期的一个代表。当初始化JSP页面时，这个对象被创建，当JSP页面由jspDestroy()方法删除时，该对象也会被删除。通过为application添加属性，可以确保生成web应用程序的所有JSP文件可以访问它。 六）config对象config对象是javax.servlet.ServletConfig的一个实例，且是用于生成的servlet的ServletConfig对象的直接包装器，在Servlet中可以通过pageContext.getServletConfig()来获取该对象。该对象允许JSP程序员访问Servlet或JSP引擎初始化参数，如路径或文件位置等。下面的config方法是唯一一个可能曾经使用的方法，且它的使用很简单：config.getServletName();这返回servlet的名称，该名称是包含在定义在web-inf\web.xml文件中元素中的字符串。 七）pageContext对象pageContext对象是javax.servlet.jsp.PageContext对象的一个实例。pageContext对象用于表示整个JSP页面。这个对象是作为一种手段来访问页面信息的，同时避免了大部分的实现细节。这个对象为每个请求存储了请求引用和响应对象。application，config，session，out对象是通过访问该对象的属性派生出来的。pageContext对象还包含发布到JSP页面的指令信息，包括缓冲信息，errorPageURL，页面范围。pageContext类定义了几个领域，包括PAGE_SCOPE，REQUEST_SCOPE，SESSION_SCOPE，和APPLICATION_SCOPE，它确定了这四个范围。它还支持40多个方法，大约一半的方法是继承了javax.servlet.jsp.JspContext类的。重要方法之一是removeAttribute()，该方法接受一个或两个参数。例如，pageContext.removeAttribute(“attrName”)从全部范围中删除属性，而下面的代码仅从页面范围中删除它：pageContext.removeAttribute(&quot;attrName&quot;, PAGE_SCOPE); 八）page对象这个对象是一个页面实例的真实引用。它可以被认为是一个对象，代表了整个JSP页面。page对象实际上是this对象的一个直接的同义词。 九）exception对象exception对象是一个包装器，包含来自先前页面的异常抛出。它通常用于为错误条件生成一个适当的响应。 JSP组件重用与JavaBean 通过重用Web组件可以提高应用程序开发的效率和其可维护性。在JSP中可以通过包含机制和JavaBean实现Web组件的重用。 包含分为静态包含和动态包含。静态包含通过include指令实现，动态包含通过标准动作jsp:include实现。 在JSP页面中使用JavaBean是最重要的组件重用技术，这主要是通过下面3个标准动作实现的：&lt;jsp:useBean&gt;&lt;jsp:setProperty&gt;&lt;jsp:getProperty&gt; 表达式语言 表达式语言（EL）是JSP 2.0新增的功能。它是一种简洁的数据访问语言，通过它可以在JSP页面中方便地访问应用程序数据，无需使用JSP表达式（&lt;%=和%&gt;）。EL的目标是使动态网页的设计、开发和维护更加容易。JSP表达式语言（EL）使得访问存储在JavaBean中的数据变得非常简单。JSP EL既可以用来创建算术表达式也可以用来创建逻辑表达式。在JSP EL表达式内可以使用整型数，浮点数，字符串，常量true、false，还有null。 EL的特点是访问数据可以使用点（.）运算符或方括号（[]）运算符；可以访问隐含对象；有自己的运算符构造表达式；可以使用Java语言编写的函数等。 EL 表达式结果 ${1}1 ${1 + 2}3 ${1.2 + 2.3}3.5 ${1.2E4 + 1.4}12001.4 ${-4 - 2}-6 ${21 * 2}42 ${3/4}0.75 ${3 div 4}0.75 ${3/0}Infinity ${10%4}2 ${10 mod 4}2 ${(1==2) ? 3 : 4}4 JSTL与标签文件 JSP标准标签库（JSP Standard Tag Library，简称JSTL）是一个为实现Web应用程序的常用功能而开发的标签库集合。功能包括基本输入输出、流程控制、XML文件解析、数据库查询、国际化和文本格式化等。JSTL主要由下面几个库组成：核心标签库；XML标签库；格式化/国际化标签库；数据库标签库；函数标签库。 这些库都很有用，但我们这里只学习核心库的使用。核心库的标签又可以分成四类，如下表所示： JSTL标签类别JSTL标签标签说明 通用目的&lt;c:out>在页面中显示内容 &lt;c:catch>捕获异常 变量支持&lt;c:set>设置一个EL变量值 &lt;c:remove>清除一个EL变量 流程控制&lt;c:if>根据一个属性等于一个值改变处理 &lt;c:choose>根据一个属性等于一组值改变处理 &lt;c:forEach>对集合中的每个对象作重复处理 &lt;c:forTokens>对给定一个文本域中的每个子串执行处理 URL处理&lt;c:url>重写URL并对它们的参数编码 &lt;c:import>访问web应用程序外部的内容 &lt;c:redirect>告诉客户浏览器访问另一个URL 标签文件（tag file）也是JSP 2.0新增的功能，它的目的是使JSP页面开发人员仅使用JSP语法就能开发标签库而无须编写Java程序。所谓标签文件就是直接使用JSP语法编写的标签。标签文件的扩展名一般为.tag或.tagx，如果标签文件包含其他完整的或片段的标签文件，JSP 2.0建议其扩展名为.tagf。在JSP页面中使用标签文件，需要在taglib动作中使用tagdir属性指定标签文件所在的目录，例如：&lt;%@ taglib prefix=&quot;mytag&quot; tagdir=&quot;/WEB-INF/tags&quot;%&gt; JSTL的安装要在JSP页面中使用JSTL标签，首先必须安装JSTL库。可以到Jakarta网站下载最新版本的JSTL。如果安装了Tomcat，可以在示例应用程序中获得JSTL，它位于\webapps\ examples\WEB-INF\lib目录中，共有两个文件：jstl.jar和standard.jar。将这两个文件复制到你的Web应用程序的WEB-INF\lib目录中，就安装了JSTL。 使用JSTL我们不用建立标签库描述文件，因为该文件已经包含在standard.jar文件中了，JSP容器可以找到该文件。另外，也可以不用配置web.xml文件，因为JSP容器使用隐含映射的方式可以将标准的URI映射到适当的标签库上。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTML</tag>
        <tag>前端</tag>
        <tag>JavaWeb</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity学习笔记——入门篇]]></title>
    <url>%2F2018%2F04%2F16%2FUnity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[这个学期，我们开始学习游戏程序制作，同时也接触到了两个2d游戏引擎，Cocos2d-x和Unity，现在就来讲讲Unity的学习心得]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习笔记——入门篇]]></title>
    <url>%2F2018%2F04%2F09%2FAndroid%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[这个学期，我们开始学习利用Android Studio制作手机游戏程序，现在就先讲讲我的学习心得]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos2d-x学习笔记——入门篇]]></title>
    <url>%2F2018%2F04%2F09%2FCocos2d-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[这个学期，我们开始学习游戏程序制作，同时也接触到了两个2d游戏引擎，Cocos2d-x和Unity，现在就先讲讲Cocos2d-x的学习心得]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Cocos2d-x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[考研计划(更新中)]]></title>
    <url>%2F2018%2F03%2F06%2F%E8%80%83%E7%A0%94%E8%AE%A1%E5%88%92-%E6%9B%B4%E6%96%B0%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[在这个寒假，家里人都在问我有没有考研计划，我苦思良久，终于还是决定试上一试。GG 考研科目共分为四项：两门公共课、一门基础课、一门专业课两门公共课（各100分）：政治（马原24分、毛概30分、史纲14分，思修16分、形政16分）、英语（完型10分、阅读A40分、阅读B（即新题型）10分、翻译10分、大作文20分、小作文10分）一门基础课（150分）：数学一（高数84分、线性代数33分、概率统计33分）一门专业课（150分）：计算机（数据结构45分、计算机组成原理45分、操作系统35分、计算机网络25分） 考研数学简单粗暴数学复习法——常规三阶段： 基础阶段（从零开始，夯实基础）（3月——6月，基础差的可以提前复习）（1）视频杨超（或汤家凤）高数基础班（跟着做题，他写什么你写什么） 链接：http://pan.baidu.com/s/1hrRdr5U 密码：dejs张宇2012线性代数强化班（对线代宏观把握，对线代全新认识）（2）书籍高数课本（定积分、不定积分、多元函数、重积分这几章课后习题一定要做！打基础别偷懒！！）线代课本（只做一些证明除外的练习题）1800题（做前面的基础题，高数和线代） 强化阶段（加强训练，深化理解）（7月——9月）（1）视频张宇高数强化班(14跨考版)——（记笔记、重在概念理解！） 链接：http://pan.baidu.com/s/1c1Xrd3i 密码：f5ki李永乐线代强化班——（重中之重，多听两遍都不为过） 链接：http://pan.baidu.com/s/1eRZoSxW 密码：xewb张伟概率强化班13版——（概率重点） 链接：http://pan.baidu.com/s/1qXV6JXq 密码：a7db（重点）链接：http://pan.baidu.com/s/1hsgCvWS 密码：txc5（补充）（2）书籍高数：李王复习全书（红皮）（主） +张宇高数18讲（辅）线代：李永乐线性代数讲义概率：张伟概率强化班讲义1800题（全科练手） 冲刺阶段（攻克难点，真题模拟）（10月——靠前）（1）视频高数 杨超高分题型精讲——（看一遍，理解，自己做一遍） 链接：http://pan.baidu.com/s/1mii6bfq 密码：0a96其他视频只看自己的薄弱点部分，对症下药，自己总结下难点，逐一攻克，实在不懂的看之前强化班或者基础班的视频，还不会问同学，上贴吧找组织。 至于数学冲刺班，基本没有太多作用，可看可不看（2）书籍1800题+1000题（大量训练）李永乐真题试卷版（红皮）（近十年真题做至少两遍）合工大超越五套卷 链接：http://pan.baidu.com/s/1kVc23UB 密码：yg2mA4纸重点难点集合本（详细用法请看我的其他答案）在强化结束之余，如果复习感觉还不错的同学，希望你能将下列的内容予以掌握，这可以帮助你更深刻的理解考研数学，可以帮你极大提高你的计算速度，而且这些内容并不会花费你太多时间。学会这些实为锦上添花。但切勿本末倒置，基础为王，谨记。 细节补充（本文特色所在 ！ ！ ！ ！ ！）微分方程——陈文灯微分算子法（解题速度极快！）—— 一天搞定无穷级数——毛纲源老师的数学复习全书无穷级数部分，很有用！—— 一个下午搞定不定积分——多项相乘用陈文灯老师的表格法！——不到两个小时掌握线性代数——张宇老师用一个向量将第一章到第六章所有内容穿针引线、一气呵成多维随机分布——方浩老师应用的卷积公式计算起来很方便—— 一个下午搞定 一、高等数学二、线性代数三、概率论与数理统计考研专业参考书目：王道单科以及真题，另外王道赠送模拟8套卷。 一.数据结构严蔚敏的数据结构 二.计算机组成原理唐朔飞的计算机组成原理 三.操作系统汤子瀛的操作系统 四.计算机网络谢希仁的计算机网络 考研英语考研政治]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML与CSS学习笔记——基础篇]]></title>
    <url>%2F2018%2F01%2F05%2FHTML%E4%B8%8ECSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[基础的HTML标签及属性，简单的CSS样式 HTML标签注释内容1&lt;!--网页HTML语言的注释方法--&gt; 根标签123&lt;html&gt; 网页主框架，最外层嵌套的标签&lt;/html&gt; 头部标签123&lt;head&gt; 网页主框架内的第一大类标签，主要用于设定网页的基本设置&lt;/head&gt; 标题栏标签123&lt;title&gt; 网页标题内容&lt;/title&gt; 正文类型标签123&lt;style&gt; 网页内嵌样式表&lt;/style&gt; 正文标签123&lt;body&gt; 网页主框架内的第二大类标签，网页的主体，也是用户能看到的部分&lt;/body&gt; 普通标签段落文本代码：&lt;p&gt;段落&lt;/p&gt;样式：段落 标题文本代码：&lt;hx&gt;标题x&lt;/hx&gt; x属于1到6 分别代表6级标题样式： 斜体强调代码：&lt;em&gt;斜体&lt;/em&gt;样式：斜体 加粗强调代码：&lt;strong&gt;加粗&lt;/strong&gt;样式：加粗 单独样式代码1：&lt;span&gt;单独&lt;/span&gt;样式1：单独代码2：&lt;div&gt;单独&lt;/div&gt;样式2：单独 引用文本代码1：&lt;q&gt;引用句&lt;/q&gt;样式1：引用句代码2：&lt;blockquote&gt;引用段&lt;/blockquote&gt;样式2：引用段 换行代码：换行&lt;br/&gt;换行样式：换行换行 空格代码：空格&amp;nbsp;空格样式：空格&nbsp;空格 水平线代码：&lt;br/&gt;样式： 联系地址信息代码：&lt;address&gt;联系地址&lt;/address&gt;样式：联系地址 代码行代码1：&lt;code&gt;代码&lt;/code&gt;样式1：代码代码2：&lt;pre&gt;代码&lt;/pre&gt;样式2：pre&gt;代码 列表（无序，在信息内容前加点；有序，在信息内容前加序号）代码1：&lt;ul&gt;&lt;li&gt;内容1&lt;/li&gt;&lt;li&gt;内容2&lt;/li&gt;&lt;/ul&gt;样式1：内容1内容2代码2：&lt;ol&gt;&lt;li&gt;内容1&lt;/li&gt;&lt;li&gt;内容2&lt;/li&gt;&lt;/ol&gt;样式2：内容1内容2 超链接文本代码：&lt;a href=&quot;链接地址或邮件地址&quot; target=&quot;打开链接的方式&quot; title=&quot;提示内容&quot;&gt;超链接&lt;/a&gt;样式：超链接 图片代码：&lt;img scr=&quot;图片地址&quot; alt=&quot;加载失败后的提示&quot; title=&quot;提示文本&quot; /&gt;样式： 表格标签代码： 123456789101112&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表头1&lt;/th&gt;&lt;th&gt;表头2&lt;/th&gt;&lt;th&gt;表头3&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt;&lt;td&gt;单元格&lt;/td&gt;&lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 样式：表头1表头2表头3单元格单元格单元格说明： 标签 作用 &lt;table&gt;&lt;/table&gt; 表格主框架 &lt;thead&gt;&lt;/thead&gt; 表格头部 &lt;tbody&gt;&lt;/tbody&gt; 表格主体 &lt;caption&gt;&lt;/caption&gt; 表格中的标题 &lt;tr&gt;&lt;/tr&gt; 表格中的一行 &lt;th&gt;&lt;/th&gt; 表格中的表头 &lt;td&gt;&lt;/td&gt; 表格中的单元格 表单标签代码： 12345678910&lt;form method="传送方式 post/get" action="服务器文件 输入数据的目标文件"&gt; &lt;input type="password/text 类型 密码显示或普通文本" /&gt; &lt;textarea cols="列数" rows="行数"&gt;&lt;/textarea&gt; &lt;input type="radio/checkbox 类型 单选或多选" checked="checked 设置默认选中" /&gt; &lt;select multiple="multiple 设置多选"&gt; &lt;option selected="selected 设置为默认值"&gt;&lt;/option&gt; &lt;/select&gt; &lt;input type="submit/reset 提交或重置表单"/&gt; &lt;label for="控件ID"&gt;&lt;/label&gt;&lt;/form&gt; 样式： 文本密码单选1单选2多选1多选21234 公有属性： 属性 作用 name 名称，为控件命名，供服务端使用，如asp、php文件，名称相同的控件视作同一组 value 显示值，也称默认值，也是表单向服务器提交的值 id ID，唯一标识控件 说明： 标签 作用 &lt;form&gt;&lt;/form&gt; 表单框架 &lt;input/&gt; 输入框，单选或多选按钮，提交或重置按钮 &lt;textarea&gt;&lt;/textarea&gt; 文本域 &lt;option&gt;&lt;/option&gt; 下拉列表 &lt;select&gt;&lt;/select&gt; 多选列表框 &lt;label&gt;&lt;/label&gt; 文本控件链接 CSS层叠样式表 位置：于头标签的style标签内增添 格式：由选择符与声明组成，其中声明又是由属性和值组成，多条声明之间由分号(;)分隔 注释：格式为/*注释内容*/ 形式 内联式：在控件或标签处，调用属性style=”CSS代码（即声明）” 嵌入式：对某一选择符标签的内容同意设置，内容嵌于&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;中 外部式：将CSS样式单独保存于一个文件中，在&lt;head&gt;标签中用&lt;link&gt;标签将文件链接 &lt;link&gt;标签属性： href=”CSS地址” rel=”stylesheet” type=”text/css”优先级 内联式 &gt; 嵌入式 &gt; 外部式一般情况下符合就近原则 选择器标签选择器即选择器为HTML标签类型 类选择器用英文.号+类名称作为选择器名，在需要的标签中添加class=&quot;类名&quot;属性即可使用类名设定的CSS样式 ID选择器用英文#号+ID名称作为选择器名，在需要的标签中添加id=&quot;ID名&quot;属性即可使用ID名设定的CSS样式ID是具有唯一性的，能且只能被一个标签调用；而类可以被重复使用；一个标签可以拥有多个类设定的样式，调用时用空格隔开。 通用选择器用英文*号作为选择器名，设定所有标签和控件的样式 特殊选择器 伪类选择器：某种状态下的样式，有选择器名+英文:号+状态名构成新的选择器名，如hover，即鼠标移动到目标标签时的状态 分组选择器：令多个选择器具有相同的样式，不同选择器之间用英文,号分开 子选择器：指定某选择器下的第一代某种子元素的样式，一般两个选择器之间用英文&gt;号分开 后代选择器：指定某选择器下的所有某种子元素的样式，一般两个选择器之间用空格分开 特性 继承性：某些样式具有继承性，即某选择器下所有元素军设定为某一样式；颜色可继承，边框不可继承 特殊性：同一元素应用不同样式时，根据权值选择实际应用样式（标签选择器为1；类选择器为10；ID选择器为100；继承的权值最低），当权值相同时，越靠后的越优先 重要性：!important最高权值，放在声明的分号前 声明部分基本声明 序号 属性名 值 1 font-family “字体” 2 font-size 字号 3 color 文字颜色，即颜色的英文或#+六位数字 4 font-weight 字体粗细，如bold表示一般粗 5 font-style 字体样式，如italic表示倾斜 6 text-decoration 文本装饰，如underline表示下划线；line-through表示删除线 7 text-indent 文本缩进，一般用字长当作单位 8 line-height 行高，一般用字长当作单位 9 letter-spacing 字间距 10 word-spacing 词间距 11 text-align 文字对齐，一般为left right center 12 background-color 背景颜色 13 font 文字统一设定，包含（样式、型式、粗细、字号、行间距、字体） 14 background 背景统一设定，包含（颜色、图片、重复方式、附件、位置） 批注：属性中的长度值单位一般为像素，即px；但有时也可以是字长，即em 元素分类：块状；内联、内联块状 块状元素用CSS声明display:block强制转换 独占一行，每个块状元素新起一行 元素的高度、宽度、行高、顶底边距都可以自行设置 宽度默认为父容器的100% 常用元素： div p hx ol ul dl table address blockquote form 内联元素用CSS声明display:inline强制转换 与其他元素同行 元素的高度、宽度、行高、顶底边距都不可自行设置 宽度、高度都随着内容改变而变化 常用元素： a span br i em strong label q var cite code 内联块状元素用CSS声明display:inline-block强制转换 与其他元素同行 元素的高度、宽度、行高、顶底边距都可以自行设置 常用元素： img input 盒子模型1边界(margin) 2边框(border) 3填充(padding) 内容 边界(margin)边界只有一个属性：size，可以分别设置某个方向上的边界，声明margin- + top/bottom/left/right即可也可以统一设置，共有四种方式margin: + 上+右+下+左/上下左右/上下+左右/上+左右+下 边框(border)边框有三个属性：宽度、样式、颜色；样式有dashed(虚线)、dotted(点)、solid(实线)可以分别设置某个方向的边框，只要在声明时，声明border- + top/bottom/left/right即可 填充(padding)填充只有一个属性：size，可以分别设置某个方向上的填充，声明padding- + top/bottom/left/right即可也可以统一设置，共有四种方式padding: + 上 右 下 左/上下左右/上下 左右/上 左右 下 布局模型流动(Flow)块状元素自上而下依次排列，默认宽度为100%；内联元素自左而右依次排列，水平显示 浮动(Float)块状元素根据设置自左而右/自右而左依次排列在CSS中声明float: + left(自左而右)/right(自右而左) 层(Layer)使所有元素如同图层一般层叠显示共有三种定位方式：position: + absolute(绝对定位，相对于父元素的位置)/relative(相对定位，相对于元素本身原来的位置)/fixed(固定位置，相对于浏览器视图的位置)设置定位后在CSS中设置top和left属性即可确定位置 CSS小技巧水平居中 text-align:center 适用于行内元素 margin: .. auto 适用于块状元素 标签，将不定宽转为定宽 display:inline 将块状转换为行内 垂直居中 设置height的值和line-height的值相同 设置属性vertical-align:middle]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理学习笔记——基础篇]]></title>
    <url>%2F2017%2F11%2F26%2F%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[数字图像处理技术概念 图像图像是人类获取视觉信息的重要手段。“图”，就是物体投射或反射光的分布；“像”是人的视觉系统接收视觉信息而在人的大脑中形成的印象或认识。前者是客观存在的，而后者是人的感觉，图像应是两者的结合，即图像是对客观存在的物体的一种相似性的、生动的写真或描述。图像分为三类：1)可见图像：全部人眼可见（可接收到）的图像，包含了客观存在的光学图像和人类用各种不同方法人工生成的图像。2)不可见物理图像：各种可测到（客观存在) 的物理特征量的空间分别所构成的一大类图像。3)数学图像：抽象的数学图像，即用数学函数表达的图像，包括连续型和离散型。 图像处理技术图像处理技术分为模拟图像处理和数字图像处理。模拟图像处理包括光学处理（利用透镜）和电子处理，如照相、电视信号处理等，其速度快，可并行处理，但精度和灵活性差。因此产生数字图像处理，它利用数字计算机或其他高速、大规模集成数字硬件，对图像信息转换来的数字电信号进行某些数字运算或处理，以期提高图像质量或达到人们所需要求的某些预期结果。数字图像处理的主要特点是图像信息量大、图像处理技术综合性强、图像信息理论与通信理论密切相关。数字图像处理技术的基本应用：图像增强/恢复；艺术级效果；医学可视化；工业检验；法律执行；人机交互。数字处理图像在生物医学 、遥感 、工业 、军事、通信、公安等领域有着广泛的应用。 图像处理的内容图像信息的获取；图像信息的存贮；图像信息的传送；图像信息处理；图像信息的输出和显示。 图像的数字化由一幅模拟图像获取一幅满足需求的数字图像，使图像便于计算机处理、分析。 图像感知和获取图像形成模型在特定坐标(x,y)处，通过传感器转换获得的f值为一正的标量。函数f(x,y)由：①入射到观察场景的光源总量； ②场景中物体反射光的总量 组成。 图像取样和量化获取图像的目标是从感知的数据中产生数字图像，但是传感器的输出是连续的电压波形，因此需要把连续的感知数据转换为数字形式。这一过程由图像的取样与量化来完成。数字化坐标值称为取样；数字化幅度值称为量化。图像的取样率：单位距离的取样数目（在两个空间方向上）。步骤可以分为：模拟图像信号=&gt;空间采样=&gt;灰度级(强度)量化坐标的数字化称为采样，幅度值的数字化称为量化。 数字图像的表示由矩阵表示，矩阵的每个元素表示为图像的一个像素。 空间和灰度分辨率空间分辨率是指图像中可分辨的最小细节，主要由采样间隔值决定。采样间隔值越小，空间分辨率越高灰度分辨率是指灰度级别中可辨别的最小变化，通常也把灰度级L称为灰度分辨率，一般情况L=2k，灰度级为L的图像一般也称为k位图像 相邻像素处于4邻域、对角邻域、8邻域的像素 邻接性像素的相邻仅说明了两个像素在位置上的关系，若再加上取值相同或相近，则称两个像素邻接。令V是用于定义邻接性的灰度值集合（相似性准则），存在三种类型的邻接性：(1)4邻接:若像素p和q的灰度值均属于V中的元素，且q在N4(p)中，则p和q是4邻接的；(2)8邻接:若像素p和q的灰度值均属于V中的元素，且q在N8(p)集中,则p和q是8邻接的；(3)m邻接(混合邻接):若像素p和q的灰度值均属于V中的元素，{①q在N4(p)中,或者②q在ND(p)中}且{集合N4(p)∩N4(q)没有V值的像素},则具有V值的像素p和q是m邻接的。m邻接可以消除8邻接所带来的（通路）二义性。 通路像素$p(x_0,y_0)$到像素$q(x_n,y_n)$的通路定义为特定的像素序列：$(x_0,y_0),(x_1,y_1), (x_2,y_2) …,(x_n,y_n), st.(x_i,y_i)$和$(x_(i-1),y_(i-1))$(对于1≤i≤n)是邻接的。n是通路的长度。若$(x_0,y_0)=(x_n,y_n)$,则通路是闭合通路。 连通性若S是图像中的一个象素子集，对任意的p,q∈S，如果存在一条由S中像素组成的从p到q的通路，则称p在图像集S中与q连通。如果S中仅有一个连通分量，则S叫连通集；所有属于S的连通到某一点p的像素点的集合被称为连通分量。 区域R是图像中的像素子集，如果R是连通集，则称R为一个区域；两个区域，如果联合（并）为一个区域，则称这两个区域为邻接区域。①定义区域时，必须指明灰度相似性准则V={ }；②定义邻接区域时，还必须指明邻接类型； 边界假设一副图像S中有K个不连接区域，且它们都不接触图像边界。前景就是所有连通分量的并集；背景就是图像出去前景的剩余像素；内边界就是一个区域的边缘或轮廓线。（即：该区域中和其背景相邻接的点的集合） 距离像素的距离一共有四种定义方式：1)欧氏距离 = $\sqrt{(x-s)^2+(y-t)^2}$；2)D4(城市街区距离)距离 = $|x-s|+|y-t|$；3)D8(棋盘距离)距离 = $max⁡(|x-s|,|y-t|)$；4)Dm距离：用点间最短的通路定义。 数字图像处理基本操作 VisualStudio图片打开与保存1.打开123456789101112131415161718192021222324252627282930313233343536CString strFilter;CSimpleArray&lt;GUID&gt; aguidFileTypes;HRESULT hResult;// 获取CImage支持的图像文件的过滤字符串hResult = m_sImage.GetExporterFilterString(strFilter, aguidFileTypes, _T("All Image Files"));if (FAILED(hResult))&#123; AfxMessageBox(_T("GetExporterFilter函数失败!")); return;&#125;// 生成打开图像文件的对话框CFileDialog dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST, strFilter);if (IDOK != dlg.DoModal()) return;// 清楚之前打开的图像文件m_sImage.Destroy();m_rImage.Destroy();// 将外部图像文件装载到CImage对象中hResult = m_sImage.Load(dlg.GetPathName());if (FAILED(hResult))&#123; AfxMessageBox(_T("图像文件加载失败！")); return;&#125;if (m_sImage.GetBPP() != 24)&#123; m_sImage.Destroy(); AfxMessageBox(_T("只处理24位色图像！")); return;&#125;bFileIsOpen = true;// 设置主窗口标题栏内容CString str;str.LoadString(AFX_IDS_APP_TITLE);AfxGetMainWnd()-&gt;SetWindowText(str + " - " + dlg.GetFileName());InvalidateRect(NULL, NULL, FALSE); 2.保存1234567891011121314151617181920212223242526272829303132333435if (m_rImage.IsNull()) &#123; AfxMessageBox(_T("你还没有生成一个要保存的图像文件！")); return;&#125;CString strFilter;strFilter = "位图文件|*.bmp|JPEG 图像文件|*.jpg|GIF 图像文件|*.gif|PNG 图像文件|*.png||";CFileDialog dlg(FALSE, NULL, NULL, NULL, strFilter);if (IDOK != dlg.DoModal()) return;// 如果用户没有指定文件扩展名，则为其添加一个CString strFileName = dlg.GetPathName();CString strExtension = dlg.GetFileExt();if (strExtension.IsEmpty())&#123; switch (dlg.m_ofn.nFilterIndex) &#123; case 1: strExtension = "bmp"; break; case 2: strExtension = "jpg"; break; case 3: strExtension = "gif"; break; case 4: strExtension = "png"; break; default: break; &#125; strFileName = strFileName + _T(".") + strExtension;&#125;// 图像保存HRESULT hResult = m_rImage.Save(strFileName);if (FAILED(hResult))&#123; AfxMessageBox(_T("保存图像文件失败！"));&#125; 图像文件基本处理1.图像文件信息读取1234567891011121314151617181920// 图像打开判断if (m_sImage.IsNull())&#123; AfxMessageBox(_T("请打开要处理的图像！")); return;&#125;// 图像属性int x, y;int nRows = m_sImage.GetHeight(); // 图像像素行数 即图像高度int nCols = m_sImage.GetWidth(); // 图像像素列数 即图像宽度int nBPP = m_sImage.GetBPP(); // 图像颜色位数// 清空并创建目标图像m_rImage.Destroy();if (!m_rImage.Create(nCols, nRows, nBPP)) return;// 读取像素数组（由一维数组储存二维数组）BYTE *sImageData = (BYTE*)m_sImage.GetBits(); // 原图像的像素数组BYTE *rImageData = (BYTE*)m_rImage.GetBits(); // 目标图像的像素数组int nRowBytes = m_sImage.GetPitch(); // 原图像的像素数组每行长度int nLineBytes = m_rImage.GetPitch(); // 目标图像的像素数组每行长度 2.图像缩小行、列的删除 123// 缩小n倍if (!m_rImage.Create(nCols/n, nRows/n, nBPP)) return; 3.图像放大1)最近邻域内插法在原图像上寻找最靠近的像素并把它的灰度值赋给栅格上的新像素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void CDigitalImageProcessingDoc::OnNearestInterpolationScaling()&#123; // TODO: 在此添加命令处理程序代码 if (m_sImage.IsNull()) &#123; AfxMessageBox(_T("请打开要处理的图像！")); return; &#125; int x; int y; CDialogScalingFactor mdlg; if (mdlg.DoModal() != IDOK) //输入水平和垂直方向放大系数 &#123; return; &#125; if (mdlg.mHoriScalingFactor &lt; 0 || mdlg.mVeriScalingFactor &lt; 0) &#123; AfxMessageBox(_T("缩放参数错误！")); return; &#125; int sWidth = m_sImage.GetWidth(); //原始图像宽度 int sHeight = m_sImage.GetHeight(); //原始图像高度 int rWidth = (int)(sWidth * mdlg.mHoriScalingFactor + 0.5); //目标图像宽度 int rHeight = (int)(sHeight * mdlg.mVeriScalingFactor + 0.5);//目标图像高度 m_rImage.Destroy(); if (!m_rImage.Create(rWidth, rHeight, m_sImage.GetBPP(), 0)) return; int sRowBytes = m_sImage.GetPitch(); int rRowBytes = m_rImage.GetPitch(); BYTE *sImageData = (BYTE *)m_sImage.GetBits(); BYTE *rImageData = (BYTE *)m_rImage.GetBits(); for (y = 1; y &lt; rHeight - 1; y++) for (x = 1; x &lt; rWidth - 1; x++) &#123; int i = (int)(x / mdlg.mHoriScalingFactor); int j = (int)(y / mdlg.mVeriScalingFactor); rImageData[y*rRowBytes + x * 3] = sImageData[j * sRowBytes + i * 3]; rImageData[y*rRowBytes + x * 3 + 1] = sImageData[j * sRowBytes + i * 3 + 1]; rImageData[y*rRowBytes + x * 3 + 2] = sImageData[j * sRowBytes + i * 3 + 2]; &#125; UpdateAllViews(NULL); // 强制调用OnDraw return;&#125; 2)双线性内插法通过公式计算新像素的灰度值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889void CDigitalImageProcessingDoc::OnBilinearInterpolationScaling()&#123; // TODO: 在此添加命令处理程序代码 if (m_sImage.IsNull()) &#123; AfxMessageBox(_T("请打开要处理的图像！")); return; &#125; int x; int y; CDialogScalingFactor mdlg; if (mdlg.DoModal() != IDOK) &#123; return; &#125; if (mdlg.mHoriScalingFactor &lt; 0 || mdlg.mVeriScalingFactor &lt; 0) &#123; AfxMessageBox(_T("缩放参数错误！")); return; &#125; int sWidth = m_sImage.GetWidth(); int sHeight = m_sImage.GetHeight(); int rWidth = (int)(sWidth * mdlg.mHoriScalingFactor + 0.5); int rHeight = (int)(sHeight * mdlg.mVeriScalingFactor + 0.5); m_rImage.Destroy(); if (!m_rImage.Create(rWidth, rHeight, m_sImage.GetBPP(), 0)) return; int sRowBytes = m_sImage.GetPitch(); int rRowBytes = m_rImage.GetPitch(); BYTE *sImageData = (BYTE *)m_sImage.GetBits(); BYTE *rImageData = (BYTE *)m_rImage.GetBits(); for (y = 1; y &lt; rHeight - 1; y++) for (x = 1; x &lt; rWidth - 1; x++) &#123; double u = x / mdlg.mHoriScalingFactor; double v = y / mdlg.mVeriScalingFactor; int i = (int)u; int j = (int)v; u = u - i; v = v - j; if ((i &gt;= sWidth - 1) &amp;&amp; (j &gt;= sHeight - 1)) &#123; rImageData[y*rRowBytes + x * 3] = sImageData[(sHeight - 1) * sRowBytes + (sWidth - 1) * 3]; rImageData[y*rRowBytes + x * 3 + 1] = sImageData[(sHeight - 1) * sRowBytes + (sWidth - 1) * 3 + 1]; rImageData[y*rRowBytes + x * 3 + 2] = sImageData[(sHeight - 1) * sRowBytes + (sWidth - 1) * 3 + 2]; &#125; else if (j &gt;= sHeight - 1) &#123; *(rImageData + y*rRowBytes + x * 3) = sImageData[(sHeight - 1) * sRowBytes + i * 3]; *(rImageData + y*rRowBytes + x * 3 + 1) = sImageData[(sHeight - 1) * sRowBytes + i * 3 + 1]; *(rImageData + y*rRowBytes + x * 3 + 2) = sImageData[(sHeight - 1) * sRowBytes + i * 3 + 2]; &#125; else if (i &gt;= sWidth - 1) &#123; rImageData[y*rRowBytes + x * 3] = sImageData[j * sRowBytes + (sWidth - 1) * 3]; rImageData[y*rRowBytes + x * 3 + 1] = sImageData[j * sRowBytes + (sWidth - 1) * 3 + 1]; rImageData[y*rRowBytes + x * 3 + 2] = sImageData[j * sRowBytes + (sWidth - 1) * 3 + 2]; &#125; else &#123; rImageData[y*rRowBytes + x * 3] = (BYTE)((1 - u)*(1 - v)*(sImageData[j * sRowBytes + i * 3]) + (1 - u)*v*(sImageData[(j + 1)*sRowBytes + i * 3]) + u*(1 - v)*(sImageData[j*sRowBytes + (i + 1) * 3]) + u*v*(sImageData[(j + 1)*sRowBytes + (i + 1) * 3])); rImageData[y*rRowBytes + x * 3 + 1] = (BYTE)((1 - u)*(1 - v)*(sImageData[j * sRowBytes + i * 3 + 1]) + (1 - u)*v*(sImageData[(j + 1)*sRowBytes + i * 3 + 1]) + u*(1 - v)*(sImageData[j*sRowBytes + (i + 1) * 3 + 1]) + u*v*(sImageData[(j + 1)*sRowBytes + (i + 1) * 3 + 1])); rImageData[y*rRowBytes + x * 3 + 2] = (BYTE)((1 - u)*(1 - v)*(sImageData[j * sRowBytes + i * 3 + 2]) + (1 - u)*v*(sImageData[(j + 1)*sRowBytes + i * 3 + 2]) + u*(1 - v)*(sImageData[j*sRowBytes + (i + 1) * 3 + 2]) + u*v*(sImageData[(j + 1)*sRowBytes + (i + 1) * 3 + 2])); &#125; &#125; UpdateAllViews(NULL); // 强制调用OnDraw return;&#125; 数字图像基本操作1.算数操作算术运算只涉及一个空间位置（象素）的运算；算术运算在相同大小的图像之间进行； 1)加作用：去除“叠加性”噪音；图像叠加。定义：g(x,y) = f(x,y) + h(x,y) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091void CDigitalImageProcessingDoc::OnImageAdd()&#123; // TODO: 在此添加命令处理程序代码 if (m_sImage.IsNull()) &#123; AfxMessageBox(_T("请打开要处理的图像！")); return; &#125; CImage lsImage; CString strFilter; CSimpleArray&lt;GUID&gt; aguidFileTypes; HRESULT hResult; // 获取CImage支持的图像文件的过滤字符串 hResult = m_sImage.GetExporterFilterString(strFilter, aguidFileTypes, _T("All Image Files")); if (FAILED(hResult)) &#123; AfxMessageBox(_T("GetExporterFilter函数失败!")); return; &#125; CFileDialog dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST, strFilter); if (IDOK != dlg.DoModal()) return; lsImage.Destroy(); // 将外部图像文件装载到CImage对象中 hResult = lsImage.Load(dlg.GetPathName()); if (FAILED(hResult)) &#123; AfxMessageBox(_T("图像文件加载失败！")); return; &#125; if (lsImage.GetBPP() != 24) &#123; lsImage.Destroy(); AfxMessageBox(_T("只处理24位色图像！")); return; &#125; if ((lsImage.GetHeight() != m_sImage.GetHeight()) || (lsImage.GetWidth() != m_sImage.GetWidth())) &#123; lsImage.Destroy(); AfxMessageBox(_T("本软件只处理相同大小图像的逻辑与代数运算！")); return; &#125; CDialogImageAddRatio mdlg; if (mdlg.DoModal() != IDOK) &#123; lsImage.Destroy(); return; &#125; double lambuda = mdlg.addRatio / 100.0; int x; int y; int nRows = m_sImage.GetHeight(); int nCols = m_sImage.GetWidth(); int nBPP = m_sImage.GetBPP(); m_rImage.Destroy(); if (!m_rImage.Create(nCols, nRows, nBPP)) &#123; lsImage.Destroy(); return; &#125; BYTE *sImageData = (BYTE *)m_sImage.GetBits(); BYTE *lsImageData = (BYTE *)lsImage.GetBits(); BYTE *rImageData = (BYTE *)m_rImage.GetBits(); int nRowBytes = m_sImage.GetPitch(); int sRowBytes = m_sImage.GetPitch(); for (y = 0; y &lt; nRows; y++) for (x = 0; x &lt; nCols; x++) &#123; rImageData[y * nRowBytes + x * 3 + 0] = (int)(lambuda * sImageData[y * nRowBytes + x * 3 + 0] + (1 - lambuda) * lsImageData[y * nRowBytes + x * 3 + 0]); rImageData[y * nRowBytes + x * 3 + 1] = (int)(lambuda * sImageData[y * nRowBytes + x * 3 + 1] + (1 - lambuda) * lsImageData[y * nRowBytes + x * 3 + 1]); rImageData[y * nRowBytes + x * 3 + 2] = (int)(lambuda * sImageData[y * nRowBytes + x * 3 + 2] + (1 - lambuda) * lsImageData[y * nRowBytes + x * 3 + 2]); &#125; lsImage.Destroy(); UpdateAllViews(NULL);&#125; 2)减作用：去除不需要的叠加性图案；检测两幅图像之间的差别；计算物体边界的梯度（差分运算）；定义：g(x,y) = f(x,y) - h(x,y) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697void CDigitalImageProcessingDoc::OnImageSub()&#123; // TODO: 在此添加命令处理程序代码 if (m_sImage.IsNull()) &#123; AfxMessageBox(_T("请打开要处理的图像！")); return; &#125; CImage lsImage; CString strFilter; CSimpleArray&lt;GUID&gt; aguidFileTypes; HRESULT hResult; // 获取CImage支持的图像文件的过滤字符串 hResult = m_sImage.GetExporterFilterString(strFilter, aguidFileTypes, _T("All Image Files")); if (FAILED(hResult)) &#123; AfxMessageBox(_T("GetExporterFilter函数失败!")); return; &#125; CFileDialog dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST, strFilter); if (IDOK != dlg.DoModal()) return; lsImage.Destroy(); // 将外部图像文件装载到CImage对象中 hResult = lsImage.Load(dlg.GetPathName()); if (FAILED(hResult)) &#123; AfxMessageBox(_T("图像文件加载失败！")); return; &#125; if (lsImage.GetBPP() != 24) &#123; lsImage.Destroy(); AfxMessageBox(_T("只处理24位色图像！")); return; &#125; if ((lsImage.GetHeight() != m_sImage.GetHeight()) || (lsImage.GetWidth() != m_sImage.GetWidth())) &#123; lsImage.Destroy(); AfxMessageBox(_T("本软件只处理相同大小图像的逻辑与代数运算！")); return; &#125; CDialogImageAddRatio mdlg; if (mdlg.DoModal() != IDOK) &#123; lsImage.Destroy(); return; &#125; double lambuda = mdlg.addRatio / 100.0; int x; int y; int nRows = m_sImage.GetHeight(); int nCols = m_sImage.GetWidth(); int nBPP = m_sImage.GetBPP(); m_rImage.Destroy(); if (!m_rImage.Create(nCols, nRows, nBPP)) &#123; lsImage.Destroy(); return; &#125; BYTE *sImageData = (BYTE *)m_sImage.GetBits(); BYTE *lsImageData = (BYTE *)lsImage.GetBits(); BYTE *rImageData = (BYTE *)m_rImage.GetBits(); int nRowBytes = m_sImage.GetPitch(); int sRowBytes = m_sImage.GetPitch(); int nrgb; for (y = 0; y &lt; nRows; y++) for (x = 0; x &lt; nCols; x++) &#123; nrgb = (int)(lambuda * sImageData[y * nRowBytes + x * 3 + 0] - (1 - lambuda) * lsImageData[y * nRowBytes + x * 3 + 0]); nrgb = (nrgb &lt; 0) ? 0 : ((nrgb&gt;255) ? 255 : nrgb); rImageData[y * nRowBytes + x * 3 + 0] = nrgb; nrgb = (int)(lambuda * sImageData[y * nRowBytes + x * 3 + 1] - (1 - lambuda) * lsImageData[y * nRowBytes + x * 3 + 1]); nrgb = (nrgb &lt; 0) ? 0 : ((nrgb&gt;255) ? 255 : nrgb); rImageData[y * nRowBytes + x * 3 + 1] = nrgb; nrgb = (int)(lambuda * sImageData[y * nRowBytes + x * 3 + 2] - (1 - lambuda) * lsImageData[y * nRowBytes + x * 3 + 2]); nrgb = (nrgb &lt; 0) ? 0 : ((nrgb&gt;255) ? 255 : nrgb); rImageData[y * nRowBytes + x * 3 + 2] = nrgb; &#125; lsImage.Destroy(); UpdateAllViews(NULL);&#125; 3)乘作用：图象的局部显示（用二值模板图像与原图像做乘法）定义：g(x,y) = f(x,y) × h(x,y) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788void CDigitalImageProcessingDoc::OnImageMul()&#123; // TODO: 在此添加命令处理程序代码 if (m_sImage.IsNull()) &#123; AfxMessageBox(_T("请打开要处理的图像！")); return; &#125; CImage lsImage; CString strFilter; CSimpleArray&lt;GUID&gt; aguidFileTypes; HRESULT hResult; // 获取CImage支持的图像文件的过滤字符串 hResult = m_sImage.GetExporterFilterString(strFilter, aguidFileTypes, _T("All Image Files")); if (FAILED(hResult)) &#123; AfxMessageBox(_T("GetExporterFilter函数失败!")); return; &#125; CFileDialog dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST, strFilter); if (IDOK != dlg.DoModal()) return; lsImage.Destroy(); // 将外部图像文件装载到CImage对象中 hResult = lsImage.Load(dlg.GetPathName()); if (FAILED(hResult)) &#123; AfxMessageBox(_T("图像文件加载失败！")); return; &#125; if (lsImage.GetBPP() != 24) &#123; lsImage.Destroy(); AfxMessageBox(_T("只处理24位色图像！")); return; &#125; if ((lsImage.GetHeight() != m_sImage.GetHeight()) || (lsImage.GetWidth() != m_sImage.GetWidth())) &#123; lsImage.Destroy(); AfxMessageBox(_T("本软件只处理相同大小图像的逻辑与代数运算！")); return; &#125; int x; int y; int nRows = m_sImage.GetHeight(); int nCols = m_sImage.GetWidth(); int nBPP = m_sImage.GetBPP(); m_rImage.Destroy(); if (!m_rImage.Create(nCols, nRows, nBPP)) &#123; lsImage.Destroy(); return; &#125; BYTE *sImageData = (BYTE *)m_sImage.GetBits(); BYTE *lsImageData = (BYTE *)lsImage.GetBits(); BYTE *rImageData = (BYTE *)m_rImage.GetBits(); int nRowBytes = m_sImage.GetPitch(); int sRowBytes = m_sImage.GetPitch(); int nrgb; for (y = 0; y &lt; nRows; y++) for (x = 0; x &lt; nCols; x++) &#123; nrgb = (int)(sImageData[y * nRowBytes + x * 3 + 0] * lsImageData[y * nRowBytes + x * 3 + 0]); nrgb = (nrgb &lt; 0) ? 0 : ((nrgb&gt;255) ? 255 : nrgb); rImageData[y * nRowBytes + x * 3 + 0] = nrgb; nrgb = (int)(sImageData[y * nRowBytes + x * 3 + 1] * lsImageData[y * nRowBytes + x * 3 + 1]); nrgb = (nrgb &lt; 0) ? 0 : ((nrgb&gt;255) ? 255 : nrgb); rImageData[y * nRowBytes + x * 3 + 1] = nrgb; nrgb = (int)(sImageData[y * nRowBytes + x * 3 + 2] * lsImageData[y * nRowBytes + x * 3 + 2]); nrgb = (nrgb &lt; 0) ? 0 : ((nrgb&gt;255) ? 255 : nrgb); rImageData[y * nRowBytes + x * 3 + 2] = nrgb; &#125; lsImage.Destroy(); UpdateAllViews(NULL);&#125; 4)除作用：增强两幅图像的差异。定义：g(x,y) = f(x,y) ÷ h(x,y)实际运算是将一幅图像取反后乘上另一幅图像 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889void CDigitalImageProcessingDoc::OnImageDiv()&#123; // TODO: 在此添加命令处理程序代码 if (m_sImage.IsNull()) &#123; AfxMessageBox(_T("请打开要处理的图像！")); return; &#125; CImage lsImage; CString strFilter; CSimpleArray&lt;GUID&gt; aguidFileTypes; HRESULT hResult; // 获取CImage支持的图像文件的过滤字符串 hResult = m_sImage.GetExporterFilterString(strFilter, aguidFileTypes, _T("All Image Files")); if (FAILED(hResult)) &#123; AfxMessageBox(_T("GetExporterFilter函数失败!")); return; &#125; CFileDialog dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST, strFilter); if (IDOK != dlg.DoModal()) return; lsImage.Destroy(); // 将外部图像文件装载到CImage对象中 hResult = lsImage.Load(dlg.GetPathName()); if (FAILED(hResult)) &#123; AfxMessageBox(_T("图像文件加载失败！")); return; &#125; if (lsImage.GetBPP() != 24) &#123; lsImage.Destroy(); AfxMessageBox(_T("只处理24位色图像！")); return; &#125; if ((lsImage.GetHeight() != m_sImage.GetHeight()) || (lsImage.GetWidth() != m_sImage.GetWidth())) &#123; lsImage.Destroy(); AfxMessageBox(_T("本软件只处理相同大小图像的逻辑与代数运算！")); return; &#125; int x; int y; int nRows = m_sImage.GetHeight(); int nCols = m_sImage.GetWidth(); int nBPP = m_sImage.GetBPP(); m_rImage.Destroy(); if (!m_rImage.Create(nCols, nRows, nBPP)) &#123; lsImage.Destroy(); return; &#125; BYTE *sImageData = (BYTE *)m_sImage.GetBits(); BYTE *lsImageData = (BYTE *)lsImage.GetBits(); BYTE *rImageData = (BYTE *)m_rImage.GetBits(); int nRowBytes = m_sImage.GetPitch(); double alpha = 0.0001; int sRowBytes = m_sImage.GetPitch(); int nrgb; for (y = 0; y &lt; nRows; y++) for (x = 0; x &lt; nCols; x++) &#123; nrgb = (int)(sImageData[y * nRowBytes + x * 3 + 0] / (lsImageData[y * nRowBytes + x * 3 + 0] + alpha)); nrgb = (nrgb &lt; 0) ? 0 : ((nrgb&gt;255) ? 255 : nrgb); rImageData[y * nRowBytes + x * 3 + 0] = nrgb; nrgb = (int)(sImageData[y * nRowBytes + x * 3 + 1] / (lsImageData[y * nRowBytes + x * 3 + 1] + alpha)); nrgb = (nrgb &lt; 0) ? 0 : ((nrgb&gt;255) ? 255 : nrgb); rImageData[y * nRowBytes + x * 3 + 1] = nrgb; nrgb = (int)(sImageData[y * nRowBytes + x * 3 + 2] / (lsImageData[y * nRowBytes + x * 3 + 2] + alpha)); nrgb = (nrgb &lt; 0) ? 0 : ((nrgb&gt;255) ? 255 : nrgb); rImageData[y * nRowBytes + x * 3 + 2] = nrgb; &#125; lsImage.Destroy(); UpdateAllViews(NULL);&#125; 2.逻辑操作在逻辑运算中，象素灰度值作为二进制串处理“与”、“或”操作可用来从一幅图像中提取子图像。 1)与(&amp;)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283void CDigitalImageProcessingDoc::OnImageAnd()&#123; // TODO: 在此添加命令处理程序代码 if (m_sImage.IsNull()) &#123; AfxMessageBox(_T("请打开要处理的图像！")); return; &#125; CImage lsImage; CString strFilter; CSimpleArray&lt;GUID&gt; aguidFileTypes; HRESULT hResult; // 获取CImage支持的图像文件的过滤字符串 hResult = m_sImage.GetExporterFilterString(strFilter, aguidFileTypes, _T("All Image Files")); if (FAILED(hResult)) &#123; AfxMessageBox(_T("GetExporterFilter函数失败!")); return; &#125; CFileDialog dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST, strFilter); if (IDOK != dlg.DoModal()) return; lsImage.Destroy(); // 将外部图像文件装载到CImage对象中 hResult = lsImage.Load(dlg.GetPathName()); if (FAILED(hResult)) &#123; AfxMessageBox(_T("图像文件加载失败！")); return; &#125; if (lsImage.GetBPP() != 24) &#123; lsImage.Destroy(); AfxMessageBox(_T("只处理24位色图像！")); return; &#125; if ((lsImage.GetHeight() != m_sImage.GetHeight()) || (lsImage.GetWidth() != m_sImage.GetWidth())) &#123; lsImage.Destroy(); AfxMessageBox(_T("本软件只处理相同大小图像的逻辑与代数运算！")); return; &#125; int x; int y; int nRows = m_sImage.GetHeight(); int nCols = m_sImage.GetWidth(); int nBPP = m_sImage.GetBPP(); m_rImage.Destroy(); if (!m_rImage.Create(nCols, nRows, nBPP)) &#123; lsImage.Destroy(); return; &#125; BYTE *sImageData = (BYTE *)m_sImage.GetBits(); BYTE *lsImageData = (BYTE *)lsImage.GetBits(); BYTE *rImageData = (BYTE *)m_rImage.GetBits(); int nRowBytes = m_sImage.GetPitch(); int sRowBytes = m_sImage.GetPitch(); for (y = 0; y &lt; nRows; y++) for (x = 0; x &lt; nCols; x++) &#123; rImageData[y * nRowBytes + x * 3 + 0] = sImageData[y * nRowBytes + x * 3 + 0] &amp; lsImageData[y * nRowBytes + x * 3 + 0]; rImageData[y * nRowBytes + x * 3 + 1] = sImageData[y * nRowBytes + x * 3 + 1] &amp; lsImageData[y * nRowBytes + x * 3 + 1]; rImageData[y * nRowBytes + x * 3 + 2] = sImageData[y * nRowBytes + x * 3 + 2] &amp; lsImageData[y * nRowBytes + x * 3 + 2]; &#125; lsImage.Destroy(); UpdateAllViews(NULL);&#125; 2)或(|)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283void CDigitalImageProcessingDoc::OnImageOr()&#123; // TODO: 在此添加命令处理程序代码 if (m_sImage.IsNull()) &#123; AfxMessageBox(_T("请打开要处理的图像！")); return; &#125; CImage lsImage; CString strFilter; CSimpleArray&lt;GUID&gt; aguidFileTypes; HRESULT hResult; // 获取CImage支持的图像文件的过滤字符串 hResult = m_sImage.GetExporterFilterString(strFilter, aguidFileTypes, _T("All Image Files")); if (FAILED(hResult)) &#123; AfxMessageBox(_T("GetExporterFilter函数失败!")); return; &#125; CFileDialog dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST, strFilter); if (IDOK != dlg.DoModal()) return; lsImage.Destroy(); // 将外部图像文件装载到CImage对象中 hResult = lsImage.Load(dlg.GetPathName()); if (FAILED(hResult)) &#123; AfxMessageBox(_T("图像文件加载失败！")); return; &#125; if (lsImage.GetBPP() != 24) &#123; lsImage.Destroy(); AfxMessageBox(_T("只处理24位色图像！")); return; &#125; if ((lsImage.GetHeight() != m_sImage.GetHeight()) || (lsImage.GetWidth() != m_sImage.GetWidth())) &#123; lsImage.Destroy(); AfxMessageBox(_T("本软件只处理相同大小图像的逻辑与代数运算！")); return; &#125; int x; int y; int nRows = m_sImage.GetHeight(); int nCols = m_sImage.GetWidth(); int nBPP = m_sImage.GetBPP(); m_rImage.Destroy(); if (!m_rImage.Create(nCols, nRows, nBPP)) &#123; lsImage.Destroy(); return; &#125; BYTE *sImageData = (BYTE *)m_sImage.GetBits(); BYTE *lsImageData = (BYTE *)lsImage.GetBits(); BYTE *rImageData = (BYTE *)m_rImage.GetBits(); int nRowBytes = m_sImage.GetPitch(); int sRowBytes = m_sImage.GetPitch(); for (y = 0; y &lt; nRows; y++) for (x = 0; x &lt; nCols; x++) &#123; rImageData[y * nRowBytes + x * 3 + 0] = sImageData[y * nRowBytes + x * 3 + 0] | lsImageData[y * nRowBytes + x * 3 + 0]; rImageData[y * nRowBytes + x * 3 + 1] = sImageData[y * nRowBytes + x * 3 + 1] | lsImageData[y * nRowBytes + x * 3 + 1]; rImageData[y * nRowBytes + x * 3 + 2] = sImageData[y * nRowBytes + x * 3 + 2] | lsImageData[y * nRowBytes + x * 3 + 2]; &#125; lsImage.Destroy(); UpdateAllViews(NULL);&#125; 3)非(~)12 3.空间处理空间操作直接在给定图像的象素上执行 1)单象素操作对图像的每个元素进行统一的函数变换操作说明：$s = T(z)$ 12 2)邻域操作处理后图像像素的灰度值由对应位置的原图像像素邻域的灰度值所确定说明：$s(x,y) = \frac{1}{S_{xy}} \sum_{i,j \in S_{xy}} f(i,j)$ 12 3)几何空间变换几何空间变换（橡皮模变换）要改变图像中象素间的空间关系。几何变换的两个基本操作：坐标的空间变换；灰度内插；说明：$\left[\begin{matrix}x&amp;y&amp;1\\\end{matrix}\right]=\left[\begin{matrix}u&amp;v&amp;1\\\end{matrix}\right] T=\left[\begin{matrix}u&amp;v&amp;1\\\end{matrix}\right]·\left[\begin{matrix}t_1&amp;t_2&amp;0\\t_3&amp;t_4&amp;0\\t_5&amp;t_6&amp;0\\\end{matrix}\right]$ 12 图像增强（空间域方法） 如果不考虑图像降质的原因，只将图像中感兴趣的特征(如边缘、轮廓、对比度等)进行强调或有选择的突出，同时衰减其它不需要的特征，以便于显示、观察或分析，此种图像处理称为图像增强（Image Enhancement）空间域方法是直接以图像中的像素操作为基础的图像增强方法 1.灰度变换（强度映射、点处理）令$f(x,y)$表示输入图像，$g(x,y)$表示处理之后的输出图像；如邻域大小为像素本身，即输出图像 $g(x,y)$任意点$(x,y)$的灰度值仅依赖于输入图象$f(x,y)$在$(x,y)$像素点的灰度值，则$T[·]$定义的操作被称为灰度级变换函数（又称灰度映射） 。令r和s分别表示输入图像$f(x,y)$和输出图像$g(x,y)$在任意点$(x,y)$的灰度级（值），灰度变换可表示为：$g(x,y)= T[f(x,y)]$ ，即：$s = T(r)$关键：寻找一个合适的变换函数T(r)，根据灰度变换函数T(r)选择方法的不同，灰度变换可分为：直方图处理方法和直接灰度变换。 1)直接灰度变换：根据问题，直接选择灰度变换函数$s=T(r)$，实现图像增强。主要处理对比度、灰度动态范围等问题。r和s分别是输入图像f (x,y)和输出图像g (x,y)在任意点(x,y)的灰度级。 常用的变换函数有：（1）线性函数（正比、反比、分段线性函数）（2）对数函数（3）幂律函数（n次幂和n次方根函数）（4）其它特殊非线性函数 图像反转当输入图像的灰度级范围为$[0, L-1]$的图像反转操作可由反比变换获得，表达式为：$s = L-1-r$用这种方式倒转图像的强度产生图像反转的对等图像。这种处理尤其适用于增强嵌入图像暗色区域的白色或灰色细节，特别是当黑色面积占主导地位时。 对数变换$s = c\times log(r+1)$ 其中，c是一个常数，且假定r≥0。对数变换常用于图像的动态范围压缩。与增强对比度相反，有时原图的动态范围太大，超出某些显示设备的允许动态范围，这时直接使用原图，则一部分细节可能丢失。 幂律（伽马）变换幂律变换的基本形式为：$s=c\times r^\gamma$。其中c和γ为正的常数。伽马校正：用于图像获取、打印和显示的各种装置根据幂次规律进行响应。习惯上，幂次等式中的指数是指伽马值，用于修正幂次响应现象的过程称做伽马校正。 分段线性变换函数（1）对比拉伸：低对比度（照明不足、传感器动态范围小）提高图像灰度级的动态范围，改善图像对比度。拐点的位置控制了变换函数的形状，保证变换函数为单值单调。（2）灰度级分层：在图像中突出显示特定范围的灰度级别。（3）位平面分层：可能需要突出显示由特定位对整个图像外观所做的贡献。 2)直方图处理（直方图均衡化、直方图匹配）如果将图像中像素灰度级看成是一个随机变量，则其取值分布情况就反映了图像的统计特性，这一特性可用灰度直方图来描述。灰度级范围为$[0, L-1]$的数字图象的灰度直方图是灰度级的离散函数：$h(r_k)=n_k$式中，$r_k$是第k级灰度值，$n_k$是图像中灰度值为$r_k$的像素的个数，$k=0,1,…, L-1$。灰度直方图是灰度级的函数，它表示图像中具有某种灰度级的像素的个数，反映了图像中每种灰度出现的频率。 归一化$p_r(r_k)=\frac{n_k}{n},k=0,1,…,L-1$其中,n 为一幅图像中像素总数,$n_k$是图像中灰度值为$r_k$的像素的个数。灰度直方图归一化处理后，$p(r_k)$可视为图像灰度级$r_k$发生的概率估计值。 直方图均衡所谓直方图均衡化，是指寻找一个灰度变换函数：$s=T(r)$使变换后的图像的像素值占有全部的灰度级并且分布均匀，从而得到一幅灰度级丰富且动态范围大的图像（即高对比度图像）。 解析证明：假设输入图像的灰度级r为连续量，并被归一化到区间[0, 1]，且r = 0表示黑色，r = 1表示白色。灰度变换函数也为连续函数：$s=T(r),0≤r≤1$也就是说，通过上述变换，每个原始图像的像素灰度值r都对应产生一个s值。由从s到r的反变换可用下式表示：$r=T^(-1)(s),0≤s≤1$变换函数T(r)应满足下列条件：（1）在0≤r≤1区间内，T(r)单值（严格）单调递增；（2）当0≤r≤1时， 0≤T(r)≤1。条件(1)保证了输出图像的灰度级从白到黑的次序不变，并保证 T(r) 的反函数存在；条件(2)则保证了变换后输出灰度级与输入有同样的范围。一幅图像的灰度级可被视为区间[0,1]的随机变量。令$p_r(r)$和$p_s(s)$分别代表随机变量r和s的概率密度函数 。由概率论理论可知，如果已知随机变量ξ的概率密度函数为$p_r(r)$ ，而随机变量η是ξ 的函数，即$η=T(ξ)$，η 的概率密度$p_s(s)$可由$p_r(r)$求出,即：$p_s(s)=p_r(r)|\frac{dr}{ds}|$所以，变换后的图像的灰度级s的概率密度函数$p_s(s)$由输人图像的灰度级r的概率密度函数$p_r(r)$，和所选择的变换函数T(r)决定。变换函数为：$s=T(r)=\int_0^r p_r(ω)dω$式中：ω是积分变量，而$\int_0^r p_r(ω)dω$是r的累积分布函数。累积分布函数是r的函数，并且单值单调地从0增加到1，所以这个变换函数满足关于T(r) 的两个条件。从微积分学(莱布尼茨准则)，我们知道关于上限的定积分的导数就是该上限的积分项，即：$\frac{ds}{dr}=\frac{dT(r)}{dr}=p_r(r)$ ，变换后的图像的灰度级 s 的概率密度函数:$p_s(s)= p_r(r)|\frac{dr}{ds}|=1$ 实现方法：（1）计算输入图像的归一化直方图。一幅图像中灰度级$r_k$出现的概率可近似为：$p_r(r_k)=\frac{n_k}{n},k=0,1,…,L-1$ 式中：L是灰度级的总数目，$n_k$是图像中灰度级为$r_k$的像素的个数，n是图像中像素总数。（2）直方图均衡化灰度变换函数的离散形式为：$s_k=T(r_k)=\sum_{j=0}^kp_r(r_j)=\sum_{j=0}^k \frac{n_j}{n}$（3）经上式变换后的$s_k$取值为小数，在实际中还要对其取整并重新量化，否则，图像整体偏亮：$s_k=int[\frac{L-1}{1-s_min}(s_k-s_min)+0.5]$（4）这样，就完成了由输入图像灰度级到输出图像灰度级的映射变换$r_k-&gt;s_k$。对输入图像中任一像素$(x,y)$,如果其灰度值为：$f(x,y)=r_k$，输出图像的灰度值为$g(x,y)=s_k$ 直方图匹配（规定化）处理后的输出图像具有指定的灰度直方图形状，以便能对图像中某种灰度级加以增强，即有选择性的增强某个灰度值范围内的对比度。这种用于使处理后的图像具有指定灰度直方图的增强方法，叫做直方图匹配或直方图规定化处理。 2.空间域滤波（模板处理）输出图像g(x,y)任意像素(x,y)的灰度值为输入图像f(x,y)事先定义的(x,y)邻域内所有像素灰度值的某种函数，即：$g(x,y)= T[f(x,y)]$ 概念 像素(x,y)的邻域(neighborhood)是以（x,y）像素为中心的正方形或矩形子图像（如3×3），也可以定义为圆形或其他形状的邻域（但矩形邻域操作方便，多被采用）。 模板运算模板又称滤波器、核、掩模、窗口等，是一个小的二维阵列，模板的系数值决定了增强处理的性质，如平滑、锐化等，这种增强方法又称空间域滤波。主要步骤为：1）将模板在图中漫游，并将模板中心与图中某个象素位置重合；2）将模板上系数与模板下对应象素相乘；3）将所有乘积相加；4）将和（模板的输出响应）赋给图中对应模板中心位置的象素。注意: 定义模板时一定指明模板中心。图像边界处理方法：忽略图像边界数据；另一种方法是在图像四周复制原图像边界像素的值，或补上必需数量的像素灰度值为零的行和列，从而使卷积核悬挂在原图像四周时可以进行正常的计算。 分类平滑空间滤波器平滑滤波器用于模糊处理和减小噪声。常见的平滑处理应用就是减噪。然而，由于图像边缘也是由图像灰度尖锐变化带来的特性，所以平滑滤波处理存在着边缘模糊的负面效应。平滑滤波器能减弱或消除图像的高频分量，因为高频分量对应图像中的区域边缘等灰度值变化较大、较快的部分，滤波器将这些分量滤除，从而使图像平滑。 均值滤波器：邻域平均滤波器的输出(响应)是包含在滤波掩模邻域内像素的简单平均值。因此，这些滤波器也称为均值滤波器，是一种低通滤波器。还可以在模板中引入了加权系数，以区分邻域中不同位置像素对输出像素值的影响，常称其为加权模板。 统计排序滤波器：统计滤波器是一种非线性的空间滤波器，它的响应基于滤波器模板包围的图像区域中像素的排序，然后由统计排序结果决定的值代替中心像素的值。统计滤波器中最常见的例子就是中值滤波器，它是将像素邻域内灰度的中值代替该像素的值。中值滤波器对处理脉冲噪声(也称为椒盐噪声，以黑白点叠加在图像上)非常有效。但是对一些细节多，特别是点、线、尖顶细节多的图像不宜采用中值滤波。中值滤波是一种非线性滤波器。 锐化空间滤波器锐化处理的主要目的是突出灰度的过渡部分，增强图像中的细节。空间域像素邻域平均法可以使图像变模糊，而均值处理与积分相类似，从逻辑角度我们可以断定，锐化处理可以用空间微分（差分）来完成。微分（差分）算子的响应强度与图像在该点灰度的突变程度有关，图像微分增强了边缘和其他突变(如噪声)并削弱了灰度变化缓慢的区域。然而由于边缘和轮廓在一幅图像中常常具有任意方向，而差分运算是有方向性的，因此和差分方向一致的边缘和轮廓便检测不出来，因而希望采用一些各向同性的检测算子，它们对任意方向的边缘和轮廓都有相同的检测能力。要注意的是，能够进行锐化处理的图像必须有较高的信噪比，否则，图像锐化后，信噪比会更低，因为锐化会提升噪声强度。一般是先去噪，再锐化操作。一阶微分处理通常会产生较宽的边缘；二阶微分处理对细节有较强的响应，如细线和孤立点；一阶微分处理一般对灰度阶梯有较强的响应；二阶微分处理对灰度级阶梯变化产生双响应。二阶微分在图像中灰度值变化相似时，对线的响应要比对阶梯强，且点比线响应强。大多数应用中，对图像增强来说，二阶微分处理比一阶微分好一些，因为形成增强细节的能力好一些。由于这一原因及实现和扩展都简单，对图像增强多应用二阶微分处理。1）拉普拉斯算子：拉普拉斯算子是常用的边缘增强算子，拉普拉斯运算也是偏导数运算的线性组合运算，而且是一种各向同性（旋转不变性）的线性运算。拉普拉斯算子为：$∇^2 f=\frac{∂^2 f}{∂x^2}+\frac{∂^2 f}{∂y^2}=[f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)]-4f(x,y)$由于拉普拉斯是一种微分算子，它的应用强调图像中灰度的突变及衰减灰度慢变化区域的灰度，这将产生一幅把图像中的浅灰色边线和突变点叠加到暗背景中的图像。将原始图像和拉普拉斯图像叠加在一起的简单方法可以保护拉普拉斯锐化处理的效果，同时又能复原背景信息。2）非锐化掩蔽和高升滤波：非锐化掩蔽：从原图像中减去其非锐化（平滑过的）图像的过程（下式k =1时），步骤：模糊原图像；从原图像中减去模糊图像（产生的差值图像称为模板）；将模板加到原图像上。高提升滤波：下式k&gt;1时。式子为：$g_{mask}(x,y)=f(x,y)-f(x,y),g(x,y)=f(x,y)+k\times g_{mask}(x,y)$3）梯度算子：$∇f=grad(f)=\left[\begin{matrix}g_x\\g_y\end{matrix}\right]=\left[\begin{matrix}\frac{∂f}{∂x}\frac{∂f}{∂y}\end{matrix}\right]=\left[\begin{matrix}f(x+1,y)-f(x,y)\\f(x,y+1)-f(x,y))\end{matrix}\right]$一般把梯度矢量的模值称为梯度，$M(x,y)=\sqrt{(g_x^2+g_y^2)}≈|g_x|+|g_y|$像素模板：$\left[\begin{matrix}z_1&amp;z_2&amp;z_3\\z_4&amp;z_5&amp;z_6\\z_7&amp;z_8&amp;z_9\end{matrix}\right]$水平垂直差分法：$\begin{cases}g_x=z_8-z_5\\g_y=z_6-z_5\end{cases}$罗伯特梯度法：$\begin{cases}g_x=z_8-z_6\\g_y=z_9-z_5\end{cases}$Sobel算子：$\begin{cases}g_x=(z_7+2z_8+z_9)-(z_1+2z_2+z_3)\\g_y=(z_3+2z_6+z_9)-(z_1+2z_4+z_7)\end{cases}$※寻找一个合适的模板（滤波核） 图像增强（频率域方法） 在图像的某种变换域内，对图像的变换值进行处理。如，先对图像进行二维傅立叶变换，再对图像的频谱进行某种修正（滤波），最后将修正后的变换值逆变换到空间域，从而获得增强后的图像。寻找一个合适的模板（滤波核） 卷积理论如果原始图像是$f(x,y)$，处理后的图像是$g(x,y)$，而$h(x,y)$是滤波器的单位冲激响应，那么，空间域滤波处理过程可由下式表示：$g(x,y) = f(x,y)*h(x,y)$如果$G(u,v)$, $H(u,v)$, $F(u,v)$分别是$g(x,y)$，$h(x,y)$和$f(x,y)$的傅里叶变换，由傅里叶变换的卷积定理可知：$g(x,y)=f(x,y)*h(x,y)$ &lt;=&gt; $G(u,v) = F(u,v)·H(u,v)$经傅里叶逆变换可得到$g(x,y)$：$g(x,y)=F^{-1}[G(u,v)]=F^{-1}[F(u,v)·H(u,v)]$两个关键：1）将图像从图像空间转换到频域空间所需的变换$F$以及再将图像从频域空间转换到图像空间所需的变换$F^{-1}$。2）在频域空间对图像进行增强处理的滤波核$H$。 卷积公式：一维$f*g(x)=\int_{-\infty}^{+\infty}f(a)g(x-a)da$离散型$f*g(x)=\sum_{a=-\infty}^{+\infty}f(a)g(x-a)$二维$f*g(x,y)=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}f(a,b)g(x-a,y-b)dadb$离散型$f*g(x,y)=\sum_{a=-\infty}^{+\infty}\sum_{b=-\infty}^{+\infty}f(a,b)g(x-a,y-b)$ 傅立叶变换连续傅立叶变换一维傅里叶变化：$F(u)=\int_{-\infty}^{+\infty} f(x)e^{-j2\pi ux}dx$ 通常称$F(u)$为$f(x)$的Fourier变换，$f(x)$为$F(u)$的Fourier反变换。令$F(u)=R(u)+jI(u)=|F(u)|e^{jθ(u)}$其中$|F(u)|=\sqrt{R(u)^2+I(u)^2}，θ(u)=arctg\frac{I(u)}{R(u)}$$F(u)$称为$f(x)$的振幅谱（频谱，傅里叶谱）；$θ(u)$称为$f(x)$的相位谱，$E(u)=|F(u)|^2$称为$f(x)$的能量谱通常，空间域指的是x的变化范围，而频率域指的是u的变化范围。二维傅里叶变化：$F(u,v)=\int_{R^2} f(x,y)e^{-j2\pi(xu+yv)}dxdy$令$F(u,v)=R(u,v)+jI(u,v)=|F(u,v)|e^{jθ(u,v)}$其中$|F(u,v)|=\sqrt{R(u,v)^2+I(u,v)^2}，θ(u,v)=arctg\frac{I(u,v)}{R(u,v)}$$F(u,v)$ 称为$f(x,y)$的振幅谱（频谱，傅里叶谱）；$θ(u,v)$ 称为$f(x,y)$的相位谱，$E(u,v)=|F(u,v)|^2$称为$f(x,y)$的能量谱 离散型傅立叶变换一维：$F(u)=\frac{1}{N}\sum_{m=0}^{N-1}f(m)e^{\frac{-j2πum}{N}}$逆变换：$f(m)=\sum_{u=0}^{N-1}F(u)e^{\frac{j2πum}{N}}$二维：$F(u,v)=\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)e^{-2jπ\left(\frac{ux}{M}+\frac{vy}{N}\right)}$逆变换：$f(x,y)=\frac{1}{MN}\sum_{u=0}^{M-1}\sum_{v=0}^{N-1}F(u,v)e^{2jπ\left(\frac{ux}{M}+\frac{vy}{N}\right)}$因为Fourier变换是一种正交变换，所以其正、反变换的系数可以有几种表示形式。 按照严格意义上的正交变换，正、反变换的系数相等，为：1/√MN 按照计算方便的角度，正、反变换的系数可以按照前面的方式给出，并且正、反变换的系数可以取反。 Fourier变换有两个好处： 可以得出信号在各个频率点上的强度；可以将卷积运算化为乘积运算。为简化问题，只讨论离散二维图像函数的Fourier变换,并且图幅参数为N×N的特殊情况。 性质 尺度变换：$af(x,y) ↔ aF(x,y)$$f(ax,by) ↔ \frac{F(\frac{u}{a},\frac{v}{b})}{ab}$$af(x,y)+bg(x,y) ↔ aF(x,y)+bG(x,y)$ 傅里叶变换的周期性：$F(u+kM,v+lN)=F(u,v)$ 平移空域平移$f(m-m_0,n-n_0)↔F(u,v)e^{\frac{-j2\pi}{N}(m_{0}u+n_{0}v)}$频域平移$f(m,n)e^{\frac{-j2\pi}{N}(mu_0+nv_0)}↔F(u-u_0,v-v_0)$只要对图像乘以$(-1)^{m+n}$，频谱的原点就会移动到中央位置，从中央到周围边界的变化即为低频到高频的变化。 可分性：$F(u,v)=F_x(F_y(f(x,y)))$，可见连续两次应用一维傅立叶变换,就可求得$F(u,v)$或$f(m,n)$。 共轭对称性：$F(u,v)=\overline{F(-u,-v)}$ 旋转不变性：如果$f(m,n)$旋转θ, 则$F(w,v)$也旋转θ Parseval定理：$\sum_{m=0}^{M-1}\sum_{n=0}^{N-1}|f(m,n)|^2=\frac{1}{N^2}\sum_{u=0}^{M-1}\sum_{v=0}^{N-1}|F(u,v)|^2$ 连续Fourier变换与离散傅立叶变换的联系及他们的物理解释 采样定理：一维采样定理，若连续信号f(t)的最高截止频率为fc ,则采样频率必须满足fs≥2fc时，才能保证采样信号不失真地表示原信号；二维采样定理，如果二维信号f(x,y)的Fourier频谱F(u,v)满足：F(u,v)=F(u,v) ,|u|≤U0,|v|≤V0，其余情况为0，其中，Uc,Vc是相应于空间变量x,y的最高截止频率，则当采样周期ΔxΔy，1/Δx=Us≥2Uc，1/Δy=Vs≥2Vc时，采样信号f(mΔx,nΔy),m,n=0, ±1, ±2…能唯一地恢复原信号f(x,y)，一般取：1/Δx=2Uc，1/Δy=2Vc，ΔxΔu=1/N，ΔyΔv=1/N Fourier 变换的统计特性：直流分量：反映了原始图像的平均亮度；能量集中：在低频区，85％，是数据编码和压缩的基础；图像的亮度突变或跳变部分对应的高频区，缓变部分分布在低频区。 快速傅里叶变换$F(u)=[F_e(u)+w_N^uF_o(u)],w_N^{ux}=exp(\frac{-j2πux}{N})$$F(u+M)= [F_e(u)-w_N^uF_o(u)],M=\frac{N}{2}$]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习笔记——入门篇]]></title>
    <url>%2F2017%2F11%2F18%2FOpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[OpenGL程序的配置与基本结构 第一步：下载配置1.GLFW：一个专门针对OpenGL的C语言库2.GLAD：OpenGL函数指针库3.stb_image：纹理图片导入4.GLM：OpenGL数学函数（向量，矩阵等的变换） 第二步：环境配置创建项目并打开项目属性；设置 c/c++目录 -&gt; 包含目录；设置 c/c++目录 -&gt; 库目录；设置 链接器 -&gt; 输入 -&gt; 附加依赖项（opengl32.lib;glfw3.lib;）；设置 链接器 -&gt; 系统 -&gt; 子系统（窗口）；设置 链接器 -&gt; 高级 -&gt; 入口点（mainCTRStartup）；添加项目已有源文件（glad.c）；新建源文件（stb_image.cpp）：#define STB_IMAGE_IMPLEMENTATION #include &lt;stb_image.h&gt; 第三步：编写自定义类1.Shader：着色器类简化源代码，对着色器文件进行读取编译新建头文件（Shader.h）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#ifndef SHADER_H#define SHADER_H#include &lt;glad/glad.h&gt;#include &lt;glm/glm.hpp&gt;#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;class Shader&#123;public: unsigned int ID; // 构造函数在动态生成着色器 Shader(const char* vertexPath, const char* fragmentPath, const char* geometryPath = nullptr) &#123; // 1. 从文件中检索顶点/片段/几何着色器源代码 std::string vertexCode; std::string fragmentCode; std::string geometryCode; std::ifstream vShaderFile; std::ifstream fShaderFile; std::ifstream gShaderFile; // 确保 ifstream 对象可以引发异常: vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit); fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit); gShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit); try &#123; // 打开文件 vShaderFile.open(vertexPath); fShaderFile.open(fragmentPath); std::stringstream vShaderStream, fShaderStream; // 将文件的缓冲区内容读入流 vShaderStream &lt;&lt; vShaderFile.rdbuf(); fShaderStream &lt;&lt; fShaderFile.rdbuf(); // 关闭文件处理程序 vShaderFile.close(); fShaderFile.close(); // 将流转换为字符串 vertexCode = vShaderStream.str(); fragmentCode = fShaderStream.str(); // 如果存在几何着色器路径, 也会加载几何着色器 if (geometryPath != nullptr) &#123; gShaderFile.open(geometryPath); std::stringstream gShaderStream; gShaderStream &lt;&lt; gShaderFile.rdbuf(); gShaderFile.close(); geometryCode = gShaderStream.str(); &#125; &#125; catch (std::ifstream::failure e) &#123; std::cout &lt;&lt; "ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ" &lt;&lt; std::endl; &#125; const char* vShaderCode = vertexCode.c_str(); const char * fShaderCode = fragmentCode.c_str(); // 2. 编译着色器 unsigned int vertex, fragment; int success; char infoLog[512]; // 编译顶点着色器 vertex = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertex, 1, &amp;vShaderCode, NULL); glCompileShader(vertex); checkCompileErrors(vertex, "VERTEX"); // 编译片断着色器 fragment = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragment, 1, &amp;fShaderCode, NULL); glCompileShader(fragment); checkCompileErrors(fragment, "FRAGMENT"); // 如果给出几何着色, 编译几何着色器 unsigned int geometry; if (geometryPath != nullptr) &#123; const char * gShaderCode = geometryCode.c_str(); geometry = glCreateShader(GL_GEOMETRY_SHADER); glShaderSource(geometry, 1, &amp;gShaderCode, NULL); glCompileShader(geometry); checkCompileErrors(geometry, "GEOMETRY"); &#125; // 着色器程序 ID = glCreateProgram(); glAttachShader(ID, vertex); glAttachShader(ID, fragment); if (geometryPath != nullptr) glAttachShader(ID, geometry); glLinkProgram(ID); checkCompileErrors(ID, "PROGRAM"); // 删除着色器, 因为它们现在已经链接到我们的程序, 不再需要 glDeleteShader(vertex); glDeleteShader(fragment); if (geometryPath != nullptr) glDeleteShader(geometry); &#125; // 激活着色器 // ------------------------------------------------------------------------ void use() &#123; glUseProgram(ID); &#125; // 实用的uniform函数 void setBool(const std::string &amp;name, bool value) const &#123; glUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value); &#125; void setInt(const std::string &amp;name, int value) const &#123; glUniform1i(glGetUniformLocation(ID, name.c_str()), value); &#125; void setFloat(const std::string &amp;name, float value) const &#123; glUniform1f(glGetUniformLocation(ID, name.c_str()), value); &#125; void setVec2(const std::string &amp;name, const glm::vec2 &amp;value) const &#123; glUniform2fv(glGetUniformLocation(ID, name.c_str()), 1, &amp;value[0]); &#125; void setVec2(const std::string &amp;name, float x, float y) const &#123; glUniform2f(glGetUniformLocation(ID, name.c_str()), x, y); &#125; void setVec3(const std::string &amp;name, const glm::vec3 &amp;value) const &#123; glUniform3fv(glGetUniformLocation(ID, name.c_str()), 1, &amp;value[0]); &#125; void setVec3(const std::string &amp;name, float x, float y, float z) const &#123; glUniform3f(glGetUniformLocation(ID, name.c_str()), x, y, z); &#125; void setVec4(const std::string &amp;name, const glm::vec4 &amp;value) const &#123; glUniform4fv(glGetUniformLocation(ID, name.c_str()), 1, &amp;value[0]); &#125; void setVec4(const std::string &amp;name, float x, float y, float z, float w) &#123; glUniform4f(glGetUniformLocation(ID, name.c_str()), x, y, z, w); &#125; void setMat2(const std::string &amp;name, const glm::mat2 &amp;mat) const &#123; glUniformMatrix2fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &amp;mat[0][0]); &#125; void setMat3(const std::string &amp;name, const glm::mat3 &amp;mat) const &#123; glUniformMatrix3fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &amp;mat[0][0]); &#125; void setMat4(const std::string &amp;name, const glm::mat4 &amp;mat) const &#123; glUniformMatrix4fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &amp;mat[0][0]); &#125;private: // 检查着色器编译/链接错误的实用功能。 void checkCompileErrors(GLuint shader, std::string type) &#123; GLint success; GLchar infoLog[1024]; if (type != "PROGRAM") &#123; glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(shader, 1024, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER_COMPILATION_ERROR of type: " &lt;&lt; type &lt;&lt; "\n" &lt;&lt; infoLog &lt;&lt; "\n -- --------------------------------------------------- -- " &lt;&lt; std::endl; &#125; &#125; else &#123; glGetProgramiv(shader, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shader, 1024, NULL, infoLog); std::cout &lt;&lt; "ERROR::PROGRAM_LINKING_ERROR of type: " &lt;&lt; type &lt;&lt; "\n" &lt;&lt; infoLog &lt;&lt; "\n -- --------------------------------------------------- -- " &lt;&lt; std::endl; &#125; &#125; &#125;&#125;;#endif 2.Camera：摄像机类合并操作，简化代码新建头文件（Camera.h） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#ifndef CAMERA_H#define CAMERA_H#include &lt;glad/glad.h&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;vector&gt;// 为照相机移动定义了几种可能的选项。用作抽象, 以远离窗口系统的特定输入方法enum Camera_Movement &#123; FORWARD, BACKWARD, LEFT, RIGHT&#125;;// 默认摄像机数值const float YAW = -90.0f;const float PITCH = 0.0f;const float SPEED = 2.5f;const float SENSITIVTY = 0.1f;const float ZOOM = 45.0f;// 一个抽象的摄像机类, 处理输入和计算相应的欧拉角度, 向量和矩阵在 OpenGL 中的使用class Camera&#123;public: // 摄像机的属性 glm::vec3 Position; glm::vec3 Front; glm::vec3 Up; glm::vec3 Right; glm::vec3 WorldUp; // 欧拉角 float Yaw; float Pitch; // 摄像机选项 float MovementSpeed; float MouseSensitivity; float Zoom; // 使用向量构造的构造函数 Camera(glm::vec3 position = glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f), float yaw = YAW, float pitch = PITCH) : Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED), MouseSensitivity(SENSITIVTY), Zoom(ZOOM) &#123; Position = position; WorldUp = up; Yaw = yaw; Pitch = pitch; updateCameraVectors(); &#125; // 具有标量值的构造函数 Camera(float posX, float posY, float posZ, float upX, float upY, float upZ, float yaw, float pitch) : Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED), MouseSensitivity(SENSITIVTY), Zoom(ZOOM) &#123; Position = glm::vec3(posX, posY, posZ); WorldUp = glm::vec3(upX, upY, upZ); Yaw = yaw; Pitch = pitch; updateCameraVectors(); &#125; // 返回使用欧拉角和LookAt矩阵计算的视图矩阵 glm::mat4 GetViewMatrix() &#123; return glm::lookAt(Position, Position + Front, Up); &#125; // 处理从任何类似键盘输入系统接收到的输入。接受摄像机定义的枚举形式的输入参数 (从窗口系统中抽象出来) void ProcessKeyboard(Camera_Movement direction, float deltaTime) &#123; float velocity = MovementSpeed * deltaTime; if (direction == FORWARD) Position += Front * velocity; if (direction == BACKWARD) Position -= Front * velocity; if (direction == LEFT) Position -= Right * velocity; if (direction == RIGHT) Position += Right * velocity; &#125; // 处理从鼠标输入系统接收的输入。接受 x 和 y 方向的偏移值。 void ProcessMouseMovement(float xoffset, float yoffset, GLboolean constrainPitch = true) &#123; xoffset*= MouseSensitivity; yoffset*= MouseSensitivity; Yaw += xoffset; Pitch += yoffset; // 确保当Pitch超出界限时, 屏幕不会被翻转 if (constrainPitch) &#123; if (Pitch &gt; 89.0f) Pitch = 89.0f; if (Pitch &lt; -89.0f) Pitch = -89.0f; &#125; // 使用更新的欧拉角度更新Front、Right和Up向量 updateCameraVectors(); &#125; // 处理从鼠标滚轮事件接收的输入。只需要在垂直轮轴上输入 void ProcessMouseScroll(float yoffset) &#123; if (Zoom &gt;= 1.0f &amp;&amp; Zoom &lt;= 45.0f) Zoom -= yoffset; if (Zoom &lt;= 1.0f) Zoom = 1.0f; if (Zoom &gt;= 45.0f) Zoom = 45.0f; &#125;private: // 计算从相机 (更新) 的欧拉角度的前矢量 void updateCameraVectors() &#123; // Calculate the new Front vector glm::vec3 front; front.x = cos(glm::radians(Yaw)) * cos(glm::radians(Pitch)); front.y = sin(glm::radians(Pitch)); front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch)); Front = glm::normalize(front); // Also re-calculate the Right and Up vector Right = glm::normalize(glm::cross(Front, WorldUp)); // Normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement. Up = glm::normalize(glm::cross(Right, Front)); &#125;&#125;;#endif 第四步：编写着色器代码文件顶点着色器：*.vs；片断着色器：*.fs; *.vs：一般情况 12345678910111213141516171819#version 330 core// 布局输入layout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aColor;layout (location = 2) in vec2 aTexCoord;// 输出out vec3 ourColor;out vec2 TexCoord;// 局外设定uniform mat4 model; // 模型本身的变化矩阵uniform mat4 view; // LookAt矩阵uniform mat4 projection; // 投影矩阵void main()&#123; gl_Position = projection * view * model * vec4(aPos, 1.0); // 乘法是由右往左看的 ourColor = aColor; TexCoord = vec2(aTexCoord.x, aTexCoord.y);&#125; *.fs：纹理图片混合 1234567891011121314#version 330 coreout vec4 FragColor;in vec3 ourColor;in vec2 TexCoord;// 纹理采样器uniform sampler2D texture[n]; // n组纹理采样器void main()&#123; // linearly interpolate between both textures (80% container, 20% awesomeface) FragColor = mix(texture(texture[0], TexCoord), texture(texture[1], TexCoord), 0.2);&#125; 第五步：创建源文件立即渲染模式注：现在已经不常用了，因此只是简单介绍 12345678910111213141516171819202122232425262728#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;int main() &#123; glfwInit(); // 初始化 GLFWwindow* window = glfwCreateWindow(800, 600, "HelloWindow", NULL, NULL); // 创建窗口 glfwMakeContextCurrent(window); if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#123; // 加载函数指针 std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl; return -1; &#125; while (!glfwWindowShouldClose(window)) &#123; // 渲染循环 glClearColor(0.2f, 0.3f, 0.3f, 1.0f); // 渲染背景 glClear(GL_COLOR_BUFFER_BIT); glBegin(GL_TRIANGLES); // 渲染图形 glColor3f(1.0, 0.0, 0.0); glVertex3f(0.0, 1.0, 0.0); glColor3f(0.0, 1.0, 0.0); glVertex3f(-1.0, -1.0, 0.0); glColor3f(0.0, 0.0, 1.0); glVertex3f(1.0, -1.0, 0.0); glEnd(); glfwSwapBuffers(window); // 交换缓存 glfwPollEvents(); // 挂起事件 &#125; glfwTerminate(); // 终止函数 return 0;&#125; 核心模式 头文件引入，以及全局变量和函数定义 123456789101112131415161718192021222324252627// 环境配置头文件#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;stb_image.h&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;#include &lt;iostream&gt;// 自定义类头文件#include "Shader.h"#include "Camera.h"// 函数声明void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow *window);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);// 窗口大小设定const unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// 摄像机初始化Camera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = SCR_WIDTH / 2.0f;float lastY = SCR_HEIGHT / 2.0f;bool firstMouse = true;// 时间float deltaTime = 0.0f; // time between current frame and last framefloat lastFrame = 0.0f; glfw：初始化 1234567glfwInit();glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // uncomment this statement to fix compilation on OS X#endif glfw：窗口创建 12345678GLFWwindow* window = glfwCreateWindow(窗口宽度, 窗口高度, "窗口标题", NULL, NULL);if (window == NULL)&#123; std::cout &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl; glfwTerminate(); return -1;&#125;glfwMakeContextCurrent(window); 窗口函数 1234glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // 窗口大小改变的响应函数glfwSetCursorPosCallback(window, mouse_callback); // 鼠标移动响应函数glfwSetScrollCallback(window, scroll_callback); // 鼠标滚轮响应函数glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // 隐藏鼠标 glad：加载OpenGL函数指针 12345if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#123; std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl; return -1;&#125; Shader：建立编译着色器项目 1Shader ourShader("shader.vs", "shader.fs"); // *.vs是顶点着色器；*.fs是片断着色器 设置顶点数据和缓冲并配置顶点属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546float vertices[n][] = &#123; // n组顶点数组 // 位置(x,y,z) // 颜色(R,G,B) // 纹理(X,Y) 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, // 右上 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, // 右下 -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, // 左下 -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, // 左上&#125;;unsigned int indices[n][] = &#123; // n组索引数组 0, 1, 3, // 第一个三角形 1, 2, 3 // 第二个三角形&#125;;glm::vec3 cubePositions[n] = &#123; // n组模型位置 glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(2.0f, 5.0f, -15.0f), glm::vec3(-1.5f, -2.2f, -2.5f), glm::vec3(-3.8f, -2.0f, -12.3f), glm::vec3(2.4f, -0.4f, -3.5f), glm::vec3(-1.7f, 3.0f, -7.5f), glm::vec3(1.3f, -2.0f, -2.5f), glm::vec3(1.5f, 2.0f, -2.5f), glm::vec3(1.5f, 0.2f, -1.5f), glm::vec3(-1.3f, 1.0f, -1.5f)&#125;;unsigned int VBOs[n], VAOs[n], EBOs[n];glGenVertexArrays(n, VAOs);glGenBuffers(n, VBOs);glGenBuffers(n, EBOs);for(int m = 0;m &lt; n;m++)&#123; // 绑定顶点数组对象 glBindVertexArray(VAOs[m]); // 绑定顶点缓冲对象 glBindBuffer(GL_ARRAY_BUFFER, VBOs[m]); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices[n]), vertices[n], GL_STATIC_DRAW); // 绑定索引数组对象 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBOs[m]); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices[n]), indices[n], GL_STATIC_DRAW); // 位置属性传入 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // 颜色属性传入 glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(1); // 纹理属性传入 glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); glEnableVertexAttribArray(2);&#125; 纹理图片的导入 123456789101112131415161718192021222324252627282930unsigned int textures[n];glGenTextures(n, textures);for(int m = 0;m &lt; n;m++)&#123; glBindTexture(GL_TEXTURE_2D, textures[m]); // 设置纹理覆盖参数 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); // // 设置纹理填充参数 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // 加载图片，创建纹理并生成MIP map int width, height, nrChannels; stbi_set_flip_vertically_on_load(true); // tell stb_image.h to flip loaded texture's on the y-axis. unsigned char* data = stbi_load("图片路径和文件名", &amp;width, &amp;height, &amp;nrChannels, 0); if (data) &#123; glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); &#125; else &#123; std::cout &lt;&lt; "Failed to load texture" &lt;&lt; std::endl; &#125; stbi_image_free(data);&#125;ourShader.use();// 告诉OpenGL每个采样器的纹理单位的归属for(int m = 0;m &lt; n;m++)&#123; ourShader.setInt("texture[m]",m); // *** 等于 片断着色器中uniform sampler2D的最后一个&#125; 渲染循环 1234567891011121314151617181920212223242526272829303132333435363738394041while (!glfwWindowShouldClose(window))&#123; // 求不同电脑的心跳或帧秒 float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // 键盘输入事件 processInput(window); // 渲染背景 glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); // 在相应的纹理单元上绑定纹理 glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, texture[0]); glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, texture[1]); ···等等 // 渲染内容 ourShader.use(); // 将投影矩阵传递给着色器 (请注意, 在这种情况下, 它可以更改每个帧) glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); ourShader.setMat4("projection", projection); // 摄像机/视图变换 glm::mat4 view = camera.GetViewMatrix(); ourShader.setMat4("view", view); glBindVertexArray(VAOs[m]); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); // EBO方式渲染图元 for (unsigned int i = 0; i &lt; 10; i++) &#123; glm::mat4 model; model = glm::translate(model, cubePositions[i]); float angle = 20.0f * (i); model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f)); ourShader.setMat4("model", model); glDrawArrays(GL_TRIANGLES, 0, 36); // 直接使用VBO的方式渲染图元 &#125; ···等等 // glfw: 交换缓冲区以及挂起输入输出事件 glfwSwapBuffers(window); glfwPollEvents();&#125; glfw：终止与释放 12345// 可选: 释放所有资源一旦他们的目标已经使用过:glDeleteVertexArrays(n, VAOs);glDeleteBuffers(n, VBOs);glfwTerminate();return 0; 其他函数 123456789101112131415161718192021222324252627282930313233343536373839// 处理所有输入: 查询 GLFW 相关按键是否按下/松开此框架并相应做出反应void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: 每当鼠标移动时, 就会调用此回调void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // 自 y 坐标从下到上反向 lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: 每当鼠标滚轮滚动时, 就会调用此回调void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125;// glfw: 每当窗口大小改变时，就会调用此回调void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; glViewport(0, 0, width, height);&#125; OpenGL常用函数功能解析 OpenGL常见几何图元绘制 参考资料 LearnOpenGL-CN：LearnOpenGL系列教程的中文版]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构小结]]></title>
    <url>%2F2017%2F07%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在经过了一个学期的数据结构课程学习后，我对数据结构也有了一定的了解，因此在这里做个简单的小结 基础知识数据结构的概念 逻辑结构 线性： 是指数据元素之间只存在一对一线性关系的数据结构 集合中必存在唯一的一个”第一个元素”和”最后的元素”； 除最后元素之外，其它数据元素均有唯一的”后继”； 除第一元素之外，其它数据元素均有唯一的”前驱”。非线性： 是指数据元素之间不只存在一对一线性关系的数据结构 一个结点元素可能对应多个直接前驱和多个后继； 必定存在至少一个根节点。 储存结构 顺序 顺序存储方法是把逻辑上相邻的结点存储在物理位置相邻的存储单元里，结点间的逻辑关系由存储单元的邻接关系来体现，由此得到的存储表示称为顺序存储结构，通常借助于程序设计语言中的数组来实现。 链式 链接存储方法它不要求逻辑上相邻的结点在物理位置上亦相邻，结点间的逻辑关系是由附加的指针字段表示的，由此得到的存储表示称为链式存储结构，链式存储结构通常借助于程序设计语言中的指针类型来实现。 索引 除建立存储结点信息外，还建立附加的索引表来标识结点的地址。索引表由若干索引项组成。 散列 选取某个函数，依照改函数来计算元素的存储位置，形成函数值和存储位置之间的一一对应，例如hash函数。 抽象数据结构(ADT) 是指一个数学模型以及定义在该模型上的一组操作，通常可以用以下三元组表示(D,S,P)其中，D是数据对象，S是D上的关系集，P是对D的基本操作集。在下文中，采用如下方式定义抽象数据类型ADT 抽象数据类型名{数据对象：&lt;数据对象的定义&gt;数据关系：&lt;数据关系的定义&gt;基本操作：&lt;基本操作的定义&gt;}ADT 抽象数据类型名其中，数据对象和数据关系的定义用伪码描述，基本操作的定义格式为基本操作名(参数表)初始条件：&lt;初始条件描述&gt;操作结果：&lt;操作结果描述&gt;算法的概念对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作。 意义 算法代表着用系统的方法描述解决问题的策略机制，也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。 描述语言 通常采用伪代码 算法的评价 时间复杂度 算法的时间复杂度是指执行算法所需要的计算工作量。一般来说，计算机算法是问题规模n的函数f(n)，算法的时间复杂度也因此记做T(n)=Ο(f(n)) 空间复杂度 算法的空间复杂度是指算法需要消耗的内存空间。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。 正确性 算法应当满足具体问题的需求。 可读性 算法的可读性是指一个算法可供人们阅读的容易程度。 健壮性 健壮性是指一个算法对不合理数据输入的反应能力和处理能力，也称为容错性。递归的概念程序调用自身的编程技巧称为递归 规律 一般来说，递归需要有边界条件、递归前进段和递归返回段。 结束 当边界条件不满足时，递归前进；当边界条件满足时，递归返回。 常见线性结构的应用线性表抽象数据结构 ADT List{ 数据对象:D={ $a_i$ | $a_i$∈ElemSet , i=1,2,···,n , n≥0 } 数据关系:R1={&lt;$a_{i-1}$,$a_i$&gt; | $a_{i-1}$ , $a_i$∈D , i=2,···,n} 基本操作: InitList(&amp;L) 初始条件：无 操作结果：构造一个空的线性表L。 DestoryList(&amp;L) 初始条件：线性表L已存在 操作结果：销毁线性表L ClearList(&amp;L) 初始条件：线性表L已存在 操作结果：将线性表L重置为空表 ListEmpty(L) 初始条件：线性表L已存在 操作结果：若L为空表，则返回TRUE，否则返回FALSE ListLength(L) 初始条件：线性表L已存在 操作结果：返回L中数据元素个数 GetElem(L,i,&amp;e) 初始条件：线性表L已存在，1≤i≤ListLength(L) 操作结果：用e返回L中第i个数据元素的值 LocateElem(L,e,compare()) 初始条件：线性表L已存在，compare()是数据元素判定函数 操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在，则返回值为0 PriorElem(L,cur_e,&amp;pre_e) 初始条件：线性表L已存在 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败，pre_e无定义 NextElem(L,cur_e,&amp;next_e) 初始条件：线性表L已存在 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无定义 ListInsert(&amp;L,i,e) 初始条件：线性表L已存在，1≤i≤ListLength(L)+1 操作结果：在L中的第i个位置之前插入新的数据元素e，L的长度加1 ListDelete(&amp;L,i,&amp;e) 初始条件：线性表L已存在且非空，1≤i≤ListLength(L) 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 ListTraverse(L,visit()) 初始条件：线性表L已存在 操作结果：依次对L的每个数据元素调用函数visit()。一旦visit()失败，则操作失败}ADT List 1.顺序表1.1 顺序表的结构定义1234567#define LIST_INIT_SIZE 100#define LISTINCREMENT 10typedef struct &#123; ElemType* elem; int length; int listsize;&#125;SqList; 1.2 构造空的顺序表12345678Status InitList_Sq(SqList &amp;L) &#123; L.elem = (ElemType*)malloc(LIST_INIT_SIZE * sizeof(ElemType)); if (!L.elem) return OK; L.length = 0; L.listsize = LIST_INIT_SIZE; return OK;&#125; 1.3 销毁顺序表123456Status DestroyList_Sq(SqList &amp;L)&#123; if (L.elem) free(L.elem); L.elem=NULL; return OK;&#125; 1.4 清空顺序表1234Status ClearList_Sq(SqList &amp;L)&#123; L.length = 0; return OK;&#125; 1.5 判断顺序表是否为空123Status ListEmpty_Sq(SqList L)&#123; return L.length == 0;&#125; 1.6 求顺序表的长度123int ListLength_Sq(SqList L)&#123; return (L.length);&#125; 1.7 返回顺序表中的第i个元素123456Status GetElem_Sq(SqList L, int i, ElemType &amp;e)&#123; if (i&lt;1 || i&gt;L.length) return ERROR; e = L.elem[i - 1]; return OK;&#125; 1.8 在顺序线性表L中查找第1个值与e满足compare()的元素的位序123456789101112int LocateElem_Sq(SqList L, ElemType e, Status(*compare)(ElemType, ElemType)) &#123; int i; ElemType* p; i = 1; p = L.elem; while (i &lt;= L.length &amp;&amp; !(*compare)(*p++, e)) ++i; if (i &lt;= L.length) return i; else return 0;&#125; 1.9 返回一个不是首元素的前驱123456789101112Status PriorElem_Sq(SqList L, ElemType cur_e, ElemType &amp;pre_e)&#123; int i = 2; if (cur_e == L.elem[0]) return ERROR; while (i &lt;= L.length &amp;&amp; (L.elem[i - 1] != cur_e)) i++; if (i == L.length + 1) return ERROR; else pre_e = L.elem[i - 2]; return OK;&#125; 1.10 返回一个不是末元素的后继12345678910Status NextElem_Sq(SqList L, ElemType cur_e, ElemType &amp;next_e)&#123; //返回一个不是末元素的后继 int i = 1; while (i &lt; L.length &amp;&amp; (L.elem[i - 1] != cur_e)) i++; if (i == L.length) return ERROR; else next_e = L.elem[i]; return OK;&#125; 1.11 在顺序线性表L的第i个元素之前插入新的元素e123456789101112131415161718Status ListInsert_Sq(SqList &amp;L, int i, ElemType e) &#123; ElemType* p; if (i &lt; 1 || i &gt; L.length+1) return ERROR; if (L.length &gt;= L.listsize) &#123; ElemType* newbase = (ElemType*)realloc(L.elem, (L.listsize+LISTINCREMENT) * sizeof (ElemType)); if (!newbase) return ERROR; L.elem = newbase; L.listsize += LISTINCREMENT; &#125; ElemType* q = &amp;(L.elem[i-1]); for (p = &amp;(L.elem[L.length - 1]); p &gt;= q; --p) *(p + 1) = *p; *q = e; ++L.length; return OK;&#125; 1.12 在顺序线性表L中删除第i个元素，并用e返回其值123456789101112Status ListDelete_Sq(SqList &amp;L, int i, ElemType &amp;e) &#123; ElemType *p, *q; if (i&lt;1 || i&gt;L.length) return ERROR; p = &amp;(L.elem[i - 1]); e = *p; q = L.elem + L.length - 1; for (++p; p &lt;= q; ++p) *(p - 1) = *p; --L.length; return OK;&#125; 1.13 遍历顺序线性表123456Status ListTraverse_Sq(SqList L, Status(*visit)(ElemType))&#123; if (ListEmpty_Sq(L))return ERROR; for (int i = 0; i &lt; L.length; i++)&#123; (*visit)(L.elem[i]); &#125;&#125; 2.链表2.1 链表数据结构的定义12345678typedef struct LNode&#123; ElemType data; struct LNode* next;&#125;* Link, * Position;typedef struct &#123; Link head, tail; int len;&#125;LinkList; 2.2 分配结点并赋值为e12345678910Status MakeNode(Link &amp;p, ElemType e)&#123; p = (Link)malloc(sizeof(struct LNode)); if (p)&#123; p-&gt;data = e; p-&gt;next = NULL; &#125; else return ERROR; return OK;&#125; 2.3 释放p所指向的结点123void FreeNode(Link &amp;p)&#123; free(p);&#125; 2.4 构造一个由L指向的空的线性表123456789101112131415Status InitList(LinkList &amp;L)&#123; Link p = NULL; MakeNode(p, 0); if (!p) exit(ERROR); L.head = p; L.tail = NULL; L.len = 0; for (int i = 1; i &lt;= 5; i++)&#123; Link s; ElemType e = i + '0'; MakeNode(s, e); InsertElem(L, i, s); &#125; return OK;&#125; 2.5 销毁由L指向的线性表123456789101112Status DestroyList(LinkList &amp;L)&#123; Link p = NULL; Link t = NULL; p = L.head; while (p-&gt;next)&#123; t = p-&gt;next; FreeNode(p); p = t; &#125; L.len = 0; return TRUE;&#125; 2.6 在链表L的第i个元素之前插入新的元素e1234567891011121314151617Status InsertElem(LinkList &amp;L, int i, Link s)&#123; Link p; if (i &lt; 1 || i &gt; L.len + 1) return ERROR; p = L.head; i--; while (i)&#123; p = p-&gt;next; i--; &#125; s-&gt;next = p-&gt;next; if (!p-&gt;next) L.tail = s; p-&gt;next = s; L.len++; return OK;&#125; 2.7 删除链表L的第i个元素1234567891011121314Status DeleteElem(LinkList &amp;L, int i)&#123; Link p; if (i &lt; 2 || i &gt; L.len + 1) return ERROR; p = L.head; i -= 2; while (i)&#123; p = p-&gt;next; i--; &#125; p-&gt;next = p-&gt;next-&gt;next; L.len--; return OK;&#125; 2.8 用e更新p所指向的当前结点1234Status SetCurElem(Link &amp;p, ElemType e)&#123; p-&gt;data = e; return OK;&#125; 2.9 返回p所指结点中元素的值123ElemType GetCurElem(Link p)&#123; return p-&gt;data;&#125; 2.10 返回p所指结点的直接前驱的位置123456789Position PriorPos(LinkList L, Link p)&#123; Link q; q = L.head; if (q-&gt;next == p) return NULL; while (q-&gt;next != p) q = q-&gt;next; return q;&#125; 2.11 用p返回线性表l中第i个结点的位置，并返回ok12345678910Status LocatePos(LinkList L, int i, Link &amp;p)&#123; p = L.head; if (i &lt;= 0 || i &gt; L.len) return ERROR; while (i)&#123; p = p-&gt;next; i--; &#125; return OK;&#125; 2.12 用一个函数遍历表中所有结点123456789101112131415Status ListTraverse(LinkList L, Status(*visit)(ElemType))&#123; Link p; int i = 0; if (!L.len) return ERROR; p = L.head-&gt;next; while (p &amp;&amp; (*visit)(p-&gt;data) &amp;&amp; (++i))&#123; p = p-&gt;next; cout &lt;&lt; ' '; if (i % 5 == 0) cout &lt;&lt; endl; &#125; if (p != NULL) return ERROR; return OK;&#125; 3.栈3.1 顺序栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#define STACK_INIT_SIZE 100#define STACKINCREMENT 10typedef struct &#123; SElemType *base, *top; int stacksize;&#125;SqStack;Status InitStack_Sq(SqStack &amp;S); //初始化栈Status StackEmpty_Sq(SqStack S); //栈是否为空int StackLength_Sq(SqStack S); //栈的长度Status GetTop_Sq(SqStack S, SElemType &amp;e); //得到栈顶Status Push_Sq(SqStack &amp;S, SElemType e); //压栈Status Pop_Sq(SqStack &amp;S, SElemType &amp;e); //出栈Status InitStack_Sq(SqStack &amp;S) &#123; S.base = (SElemType*)malloc(STACK_INIT_SIZE*(sizeof(SElemType))); if (!S.base) exit(OVERFLOW); S.top = S.base; S.stacksize = STACK_INIT_SIZE; return OK;&#125;Status StackEmpty_Sq(SqStack S) &#123; if (S.base == S.top) return TRUE; else return FALSE;&#125;int StackLength_Sq(SqStack S) &#123; if (S.base == S.top) return ERROR; else return (S.top - S.base);&#125;Status GetTop_Sq(SqStack S, SElemType &amp;e) &#123; if (StackEmpty_Sq(S)) return ERROR; e = *(S.top - 1); return OK;&#125;Status Push_Sq(SqStack &amp;S, SElemType e) &#123; if (S.top - S.base &gt;= S.stacksize) &#123; S.base = (SElemType*)realloc(S.base, (S.stacksize + STACKINCREMENT) * sizeof(SElemType)); if (!S.base)exit(OVERFLOW); S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; &#125; *S.top++ = e; return OK;&#125;Status Pop_Sq(SqStack &amp;S, SElemType &amp;e) &#123; if (StackEmpty_Sq(S)) return ERROR; e = *(--S.top); return OK;&#125;Status StackTraverse_Sq(SqStack S) &#123; // if (StackEmpty_Sq(S)) return ERROR; for (SElemType *i = S.top - 1; i &gt;= S.base; i--) &#123; cout &lt;&lt; *i &lt;&lt; ' '; &#125; cout &lt;&lt; endl; return OK;&#125; 3.2 链栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667typedef struct SNode &#123; SElemType data; SNode *next;&#125;*SLink, *SPosition;typedef struct &#123; SLink head, tail; int len;&#125;LinkStack;Status MakeNode(SLink &amp;p, SElemType e) &#123; //分配由p指向的结点并赋值为e p = (SLink)malloc(sizeof(SNode)); if (p) &#123; p-&gt;data = e; p-&gt;next = NULL; &#125; else return ERROR; return OK;&#125;Status InitStack_Link(LinkStack &amp;L) &#123; //构造一个由L指向的空的线性表 SLink p = NULL; MakeNode(p, 0); if (!p) exit(ERROR); L.head = p; L.tail = NULL; L.len = 0; return OK;&#125;Status Push_Link(LinkStack &amp;L, SLink s) &#123; //将s指向的结点插入线性链表的第一个结点之前 s-&gt;next = L.head-&gt;next; if (!L.head-&gt;next) L.tail = s; L.head-&gt;next = s; L.len++; return OK;&#125;Status Pop_Link(LinkStack &amp;L, SLink &amp;q) &#123; //删除表中第一个结点并以q返回 if (!L.head-&gt;next) return ERROR; q = L.head-&gt;next; L.head-&gt;next = L.head-&gt;next-&gt;next; L.len--; return OK;&#125;Status GetTop_Link(LinkStack L, SElemType &amp;e) &#123; //获得栈顶节点的值 if (!L.head-&gt;next) return ERROR; e = L.head-&gt;next-&gt;data; return OK;&#125;Status StackTraverse_Link(LinkStack L) &#123; // if (!L.head-&gt;next) return ERROR; SLink p; p = L.head-&gt;next; while (p) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; ' '; p = p-&gt;next; &#125; cout &lt;&lt; endl; return OK;&#125; 4.队列4.1 循环队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define MAXSIZE 100typedef struct &#123; QElemType *base; int front, rear;&#125;SqQueue;Status InitQueue_Sq(SqQueue &amp;Q) &#123; //初始化 Q.base = (QElemType*)malloc(MAXSIZE * sizeof(QElemType)); if (!Q.base) exit(OVERFLOW); Q.front = Q.rear = 0; return OK;&#125;int QueueLength_Sq(SqQueue Q) &#123; return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;&#125;Status EnQueue_Sq(SqQueue &amp;Q, QElemType e) &#123; //插入 if ((Q.rear + 1) % MAXSIZE == Q.front) return ERROR; Q.base[Q.rear] = e; Q.rear = (Q.rear + 1) % MAXSIZE; return OK;&#125;Status DeQueue_Sq(SqQueue &amp;Q, QElemType &amp;e) &#123; //删除 if (Q.front == Q.rear) return ERROR; e = Q.base[Q.front]; Q.front = (Q.front + 1) % MAXSIZE; return OK;&#125;Status GetTop_Sq(SqQueue Q, QElemType &amp;e) &#123; //获取队首元素 if (Q.front == Q.rear) return ERROR; e = Q.base[Q.front]; return OK;&#125;Status QueueTraverse_Sq(SqQueue Q) &#123; if (Q.front == Q.rear) return ERROR; for (int a = Q.front; Q.base[a] &amp;&amp; (a != Q.rear); a = (a + 1) % MAXSIZE) &#123; cout &lt;&lt; Q.base[a] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; return OK;&#125; 4.2 链队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384typedef struct QNode &#123; QElemType data; QNode *next;&#125;QNode, *QueuePtr;typedef struct &#123; QueuePtr front, rear;&#125;LinkQueue;Status InitQueue_Link(LinkQueue &amp;Q);//构造一个空队列QStatus QueueEmpty_Link(LinkQueue Q);//若Q为空队列，则返回TRUE，否则返回FALSEint QueueLength_Link(LinkQueue Q);//求队列的长度Status GetHead_Link(LinkQueue Q, QElemType &amp;e);//若队列不空，则用e返回Q的队头元素，并返回OK，否则返回ERRORStatus EnQueue_Link(LinkQueue &amp;Q, QElemType e);//插入元素e为Q的新的队尾元素Status DeQueue_Link(LinkQueue &amp;Q, QElemType &amp;e);//若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERRORStatus InitQueue_Link(LinkQueue &amp;Q) &#123; // 构造一个空队列Q Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode)); if (!Q.front) exit(OVERFLOW); Q.front-&gt;next = NULL; return OK;&#125;Status QueueEmpty_Link(LinkQueue Q) &#123; // 若Q为空队列，则返回TRUE，否则返回FALSE if (Q.front-&gt;next == NULL) return TRUE; else return FALSE;&#125;int QueueLength_Link(LinkQueue Q) &#123; // 求队列的长度 int i = 0; QueuePtr p; p = Q.front; while (Q.rear != p) &#123; i++; p = p-&gt;next; &#125; return i;&#125;Status GetHead_Link(LinkQueue Q, QElemType &amp;e) &#123; // 若队列不空，则用e返回Q的队头元素，并返回OK，否则返回ERROR QueuePtr p; if (QueueEmpty_Link(Q)) return ERROR; p = Q.front-&gt;next; e = p-&gt;data; return OK;&#125;Status EnQueue_Link(LinkQueue &amp;Q, QElemType e) &#123; // 插入元素e为Q的新的队尾元素 QueuePtr p; p = (QueuePtr)malloc(sizeof(QNode)); if (!p) exit(OVERFLOW); p-&gt;data = e; p-&gt;next = NULL; Q.rear-&gt;next = p; Q.rear = p; return OK;&#125;Status DeQueue_Link(LinkQueue &amp;Q, QElemType &amp;e) &#123; // 若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR QueuePtr p; if (QueueEmpty_Link(Q)) return ERROR; p = Q.front-&gt;next; e = p-&gt;data; Q.front-&gt;next = p-&gt;next; if (Q.rear == p) Q.rear = Q.front; free(p); return OK;&#125;Status QueueTraverse_Link(LinkQueue Q) &#123; if(QueueEmpty_Link(Q)) return ERROR; QueuePtr p = Q.front-&gt;next; while (p) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; ' '; p = p-&gt;next; &#125; cout &lt;&lt; endl; return OK;&#125; 5.串123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203typedef struct&#123; char *ch; int length;&#125;HString;void InitString(HString &amp;T);//初始化(产生空串)字符串TStatus StrAssign(HString &amp;T, char *chars);//生成一个其值等于串常量chars的串TStatus StrCopy(HString &amp;T, HString S);//复制串SStatus StrEmpty(HString S);//判断串S是否为空int StrLength(HString S);//返回S的元素个数，称为串的长度int StrCompare(HString S, HString T);//若S&gt;T，则返回&gt;0；若S&lt;T，则返回&lt;0；若S=T，则返回=0Status ClearString(HString &amp;S);//将S清空Status Concat(HString &amp;T, HString S1, HString S2);//链接两个串Status SubString(HString &amp;Sub, HString S, int pos, int len);//返回串S的第pos个字符起长度为len的子串int Index(HString S, HString T, int pos);//返回主串S存在的pos位置之后第一次出现的子串T的位置Status Replace(HString &amp;S, HString T, HString V);//用V替换S中所有TStatus StrInsert(HString &amp;S, int pos, HString T);//S中pos后插入TStatus StrDelete(HString &amp;S, int pos, int len);//S中pos后删除len个字符void InitString(HString &amp;T)&#123; T.length = 0; T.ch = NULL;&#125;Status StrAssign(HString &amp;T, char *chars)&#123; int i, j; if (T.ch) free(T.ch); i = strlen(chars); if (!i) &#123; T.ch = NULL; T.length = 0; &#125; else&#123; T.ch = (char*)malloc(i*sizeof(char)); if (!T.ch) exit(OVERFLOW); for (j = 0; j&lt;i; j++) T.ch[j] = chars[j]; T.length = i; &#125; return OK;&#125;Status StrCopy(HString &amp;T, HString S)&#123; /* 初始条件:串S存在。操作结果: 由串S复制得串T */ int i; if (T.ch) free(T.ch); T.ch = (char*)malloc(S.length*sizeof(char)); if (!T.ch) exit(OVERFLOW); for (i = 0; i&lt;S.length; i++) T.ch[i] = S.ch[i]; T.length = S.length; return OK;&#125;Status StrEmpty(HString S)&#123; /* 初始条件: 串S存在。操作结果: 若S为空串,则返回TRUE,否则返回FALSE */ if (S.length == 0 &amp;&amp; S.ch == NULL) return TRUE; else return FALSE;&#125;int StrCompare(HString S, HString T)&#123; /* 若S&gt;T,则返回值&gt;0;若S=T,则返回值=0;若S&lt;T,则返回值&lt;0 */ int i; for (i = 0; i &lt; S.length &amp;&amp; i &lt; T.length; ++i) if (S.ch[i] != T.ch[i]) return S.ch[i] - T.ch[i]; return S.length - T.length;&#125;int StrLength(HString S)&#123; /* 返回S的元素个数,称为串的长度 */ return S.length;&#125;Status ClearString(HString &amp;S)&#123; /* 将S清为空串 */ if (S.ch)&#123; free(S.ch); S.ch = NULL; &#125; S.length = 0; return OK;&#125;Status Concat(HString &amp;T, HString S1, HString S2)&#123; /* 用T返回由S1和S2联接而成的新串 */ int i; if (T.ch) free(T.ch); T.length = S1.length + S2.length; T.ch = (char *)malloc(T.length*sizeof(char)); if (!T.ch) exit(OVERFLOW); for (i = 0; i&lt;S1.length; i++) T.ch[i] = S1.ch[i]; for (i = 0; i&lt;S2.length; i++) T.ch[S1.length + i] = S2.ch[i]; return OK;&#125;Status SubString(HString &amp;Sub, HString S, int pos, int len)&#123; int i; if (pos&lt;1 || pos&gt;S.length || len&lt;0 || len&gt;S.length - pos + 1) return ERROR; if (Sub.ch) free(Sub.ch); if (!len)&#123; Sub.ch = NULL; Sub.length = 0; &#125; else&#123; Sub.ch = (char*)malloc(len*sizeof(char)); if (!Sub.ch) exit(OVERFLOW); for (i = 0; i &lt;= len - 1; i++) Sub.ch[i] = S.ch[pos - 1 + i]; Sub.length = len; &#125; return OK;&#125;int Index(HString S, HString T, int pos)&#123; int n, m, i; HString sub; InitString(sub); if (pos&gt;0)&#123; n = StrLength(S); m = StrLength(T); i = pos; while (i &lt;= n - m + 1)&#123; SubString(sub, S, i, m); if (StrCompare(sub, T) != 0) ++i; else return i; &#125; &#125; return 0;&#125;int Index_KMP(HString S, HString T, int pos) &#123; // 利用模式串T的next函数求T在主串S中第pos个字符之后的位置的 int *next = (int *)malloc((T.length + 1) * sizeof(int)); int i = 1; next[1] = 0; int j = 0; while (i&lt;T.length) &#123; if (j == 0 || T.ch[i] == T.ch[j]) &#123; ++i; ++j; next[i] = j; &#125; else j = next[j]; &#125; i = pos; j = 1; while (i &lt; S.length &amp;&amp; j &lt; T.length) &#123; if (j == 0 || S.ch[i] == T.ch[j]) &#123; ++i; ++j; &#125; else j = next[j]; &#125; if (j &gt;= T.length) return i - (T.length - 1); else return 0;&#125;Status StrInsert(HString &amp;S, int pos, HString T)&#123; int i; if (pos&lt;1 || pos&gt;S.length + 1) return ERROR; if (T.length)&#123; S.ch = (char*)realloc(S.ch, (S.length + T.length)*sizeof(char)); if (!S.ch) exit(OVERFLOW); for (i = S.length - 1; i &gt;= pos - 1; --i) S.ch[i + T.length] = S.ch[i]; for (i = 0; i&lt;T.length; i++) S.ch[pos - 1 + i] = T.ch[i]; S.length += T.length; &#125; return OK;&#125;Status StrDelete(HString &amp;S, int pos, int len)&#123; int i; if (S.length&lt;pos + len - 1) exit(ERROR); for (i = pos - 1; i &lt;= S.length - len; i++) S.ch[i] = S.ch[i + len]; S.length -= len; S.ch = (char*)realloc(S.ch, S.length*sizeof(char)); return OK;&#125;Status Replace(HString &amp;S, HString T, HString V)&#123; int i = 1; if (StrEmpty(T)) return ERROR; do &#123; i = Index(S, T, i); if (i) &#123; StrDelete(S, i, StrLength(T)); StrInsert(S, i, V); i += StrLength(V); &#125; &#125; while (i); return OK;&#125;void StrPrint(HString T)&#123; int i; for (i = 0; i&lt;T.length; i++) printf("%c", T.ch[i]); printf("\n");&#125; 6.数组(十字链表实现)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169typedef struct Node &#123;//十字链表的节点 int i, j; ElemType e; Node *down, *right;&#125;OLNode, *OLink;class SMatrix_OL &#123;private: OLink *rhead, *chead;//十字链表行指针、列指针 int mu, nu, tu;//十字链表所表示矩阵的行数mu、列数nu、非零元个数tupublic: SMatrix_OL(int m = 0, int n = 0, int t = 0);//构造矩阵，即声明szlb类的同时传入行数、列数、非零元个数、并进行相应的初始化 Status InsertOLNode(OLNode *p);//节点的插入 Status DeleteOLNode(int i, int j, OLNode *e);//节点的删除 。。。 暂时并没有什么卵用 OLink GetRHead(int i) &#123; // 获得行指针数组的头指针 return rhead[i]; &#125; OLink GetCHead(int i) &#123; // 获得列指针数组的头指针 return chead[i]; &#125; int GetMu() &#123; return mu; &#125; //这个，以及下面两个 分别获得矩阵的行数mu、列数nu、非零元个数tu int GetNu() &#123; return nu; &#125; int GetTu() &#123; return tu; &#125; Status Create(); // 创建十字链表 SMatrix_OL Transpose(); // 转置十字链表，返回值为 转置后的链表类 SMatrix_OL operator+(SMatrix_OL b); void Output(); // szlb的输出&#125;;//szlbSMatrix_OL::SMatrix_OL(int m, int n, int t) &#123; mu = m; nu = n; tu = t; rhead = (OLink *)malloc((m + 1) * sizeof(OLink)); chead = (OLink *)malloc((n + 1) * sizeof(OLink)); for (int x = 1; x &lt;= m; x++) rhead[x] = NULL; for (int y = 1; y &lt;= n; y++) chead[y] = NULL;&#125;//SMatrix_OL()void MakeNode(int i, int j, ElemType e, OLNode *p) &#123; // 创建节点的函数，就是将相应的值赋值给相应的变量 p-&gt;i = i; p-&gt;j = j; p-&gt;e = e; p-&gt;down = NULL; p-&gt;right = NULL;&#125;//MakeNode()Status SMatrix_OL::InsertOLNode(OLNode *p) &#123; //根据书上算法实现的节点插入 int i = p-&gt;i, j = p-&gt;j; OLNode *q; //行插入 if (rhead[i] == NULL || rhead[i]-&gt;j &gt; j) &#123; p-&gt;right = rhead[i]; rhead[i] = p; &#125;//if else &#123; for (q = rhead[i]; (q-&gt;right) &amp;&amp; (q-&gt;right-&gt;j &lt; j); q = q-&gt;right);//获取插入位置的前一个节点 if ((q-&gt;right) &amp;&amp; (q-&gt;right-&gt;j == j))return ERROR; p-&gt;right = q-&gt;right; q-&gt;right = p; &#125;//else //列插入 if (chead[j] == NULL || chead[j]-&gt;i &gt; i) &#123; p-&gt;down = chead[j]; chead[j] = p; &#125;//if else &#123; for (q = chead[j]; (q-&gt;down) &amp;&amp; (q-&gt;down-&gt;i &lt; i); q = q-&gt;down);//获取插入位置的前一个节点 if ((q-&gt;down) &amp;&amp; (q-&gt;down-&gt;i == i))return ERROR; p-&gt;down = q-&gt;down; q-&gt;down = p; &#125;//else tu++;//非零元个数加一 return OK;&#125;//InsertOLNode()Status SMatrix_OL::DeleteOLNode(int i, int j, OLNode *e) &#123; // ：） 随便看看就好 OLNode *p, *q; if (rhead[i] == NULL || rhead[i]-&gt;j &gt; j || chead[j] == NULL || chead[j]-&gt;i &gt; i) return ERROR; else &#123; for (q = rhead[i]; (q-&gt;right) &amp;&amp; (q-&gt;right-&gt;j &lt; j); q = q-&gt;right)p = q; if ((q-&gt;right) &amp;&amp; (q-&gt;right-&gt;j == j)) &#123; q-&gt;right = q-&gt;right-&gt;right; &#125;//if else return ERROR; for (q = chead[j]; (q-&gt;down) &amp;&amp; (q-&gt;down-&gt;i &lt; i); q = q-&gt;down); if ((q-&gt;down) &amp;&amp; (q-&gt;down-&gt;i == i)) &#123; q-&gt;down = q-&gt;down-&gt;down; &#125;//if else return ERROR; &#125;//else return OK;&#125;//DeleteOLNode()Status SMatrix_OL::Create() &#123; int m, n, t; OLNode *p; int i, j; ElemType e; cout &lt;&lt; "请分别输入m,n,t"; cin &gt;&gt; m &gt;&gt; n &gt;&gt; t; mu = m; nu = n; if (!(rhead = (OLink *)malloc((m + 1) * sizeof(OLink)))) return ERROR; if (!(chead = (OLink *)malloc((n + 1) * sizeof(OLink)))) return ERROR; for (int x = 1; x &lt;= m; x++) rhead[x] = NULL; for (int y = 1; y &lt;= n; y++) chead[y] = NULL; for (int z = 1; z &lt;= t; z++) &#123; cout &lt;&lt; "请分别输入i,j,e"; cin &gt;&gt; i &gt;&gt; j &gt;&gt; e; if (!(p = (OLNode *)malloc(sizeof(OLNode)))) return ERROR; MakeNode(i, j, e, p); InsertOLNode(p); &#125;//for return OK;&#125;//Create()SMatrix_OL SMatrix_OL::Transpose() &#123; // 转置函数 SMatrix_OL b(nu, mu); OLNode *p, *q; int i, j; ElemType e; for (int x = 1; x &lt;= nu; x++) &#123; q = chead[x]; while (q) &#123; p = (OLNode *)malloc(sizeof(OLNode)); i = q-&gt;j; j = q-&gt;i; e = q-&gt;e; MakeNode(i, j, e, p); b.InsertOLNode(p); q = q-&gt;down; &#125;//while &#125;//for return b;&#125;// Transpose()SMatrix_OL SMatrix_OL::operator+(SMatrix_OL b) &#123;//实现十字链表表示的矩阵的相加 SMatrix_OL c(mu, nu); OLNode *p, *q, *r; int i, j; ElemType e; for (int x = 1; x &lt;= mu; x++) &#123; p = rhead[x]; q = b.GetRHead(x); while (p || q) &#123; r = (OLNode *)malloc(sizeof(OLNode)); i = x; if (!q || (p &amp;&amp; p-&gt;j &lt; q-&gt;j)) &#123; j = p-&gt;j; e = p-&gt;e; MakeNode(i, j, e, r); p = p-&gt;right; &#125;//if else if (!p || (q &amp;&amp; p-&gt;j &gt; q-&gt;j)) &#123; j = q-&gt;j; e = q-&gt;e; MakeNode(i, j, e, r); q = q-&gt;right; &#125;//else if else &#123; j = p-&gt;j; e = p-&gt;e + q-&gt;e; MakeNode(i, j, e, r); p = p-&gt;right; q = q-&gt;right; &#125;//else if (e == 0)continue; c.InsertOLNode(r); &#125;//while &#125;//for return c;&#125;//operator+() 常见非线性结构的应用1.二叉树1.1 二叉树的定义与遍历12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788typedef struct BiTNode &#123; TElemType data; struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree;Status CreateBiTree(BiTree &amp;T);//先序创建二叉树Status PreOrderTraverse(BiTree T, Status(*Visit)(TElemType));//先序遍历二叉树Status InOrderTraverse(BiTree T, Status(*Visit)(TElemType));//中序遍历二叉树Status PostOrderTraverse(BiTree T, Status(*Visit)(TElemType));//后序遍历二叉树Status LevelOrderTraverse(BiTree T, Status(*Visit)(TElemType));//层序遍历二叉树Status CreateBiTree(BiTree &amp;T) &#123; TElemType ch; if (cin.peek() == ' ') &#123; cin.get(); T = NULL; &#125; else &#123; cin &gt;&gt; ch; if (!(T = (BiTNode*)malloc(sizeof(BiTNode))))return ERROR; T-&gt;data = ch; CreateBiTree(T-&gt;lchild); CreateBiTree(T-&gt;rchild); &#125; return OK;&#125;Status PreOrderTraverse(BiTree T, Status(*Visit)(TElemType)) &#123; if (T) &#123; if (Visit(T-&gt;data)) if (PreOrderTraverse(T-&gt;lchild, Visit)) if (PreOrderTraverse(T-&gt;rchild, Visit)) return OK; return ERROR; &#125; else return OK;&#125;Status InOrderTraverse(BiTree T, Status(*Visit)(TElemType)) &#123; if (T) &#123; if (InOrderTraverse(T-&gt;lchild, Visit)) if (Visit(T-&gt;data)) if (InOrderTraverse(T-&gt;rchild, Visit)) return OK; return ERROR; &#125; else return OK;&#125;Status PostOrderTraverse(BiTree T, Status(*Visit)(TElemType)) &#123; if (T) &#123; if (PostOrderTraverse(T-&gt;lchild, Visit)) if (PostOrderTraverse(T-&gt;rchild, Visit)) if (Visit(T-&gt;data)) return OK; return ERROR; &#125; else return OK;&#125;Status LevelOrderTraverse(BiTree T, Status(*Visit)(TElemType)) &#123; if (!T)return ERROR; deque&lt;BiTree&gt; Qh, Ql; BiTree t; Ql.push_back(T); do &#123; Qh.swap(Ql); Ql.clear(); while (!Qh.empty()) &#123; t = Qh.front(); Qh.pop_front(); if (t) &#123; Visit(t-&gt;data); if (t-&gt;lchild)Ql.push_back(t-&gt;lchild); if (t-&gt;rchild)Ql.push_back(t-&gt;rchild); &#125; &#125; &#125; while (!Ql.empty()); return OK;&#125;Status PrintElement(TElemType e) &#123; printf("%c ", e); return OK;&#125;Status Swap(BiTree &amp;T) &#123; if (T) &#123; Swap(T-&gt;lchild); Swap(T-&gt;rchild); BiTree tmp = T-&gt;lchild; T-&gt;lchild = T-&gt;rchild; T-&gt;rchild = tmp; &#125; return OK;&#125; 1.2 二叉树的应用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182typedef struct BiTNode &#123; TElemType data; struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree;Status CreateBiTree(BiTree &amp;T);//先序创建二叉树int GetLevesNum(BiTree T);//叶子结点数int GetNonlevesNum(BiTree T);//非叶子结点数int GetAllNum(BiTree T);//所有结点数int Depth(BiTree T);//树的深度Status SearchFromTree(BiTree T, TElemType value);//查找Status OutputAllPath(BiTree T);//输出所有到叶节点的路径Status CreateBiTree(BiTree &amp;T) &#123; TElemType ch; if (cin.peek() == ' ' || cin.peek() == 13) &#123; cin.get(); T = NULL; &#125; else &#123; cin &gt;&gt; ch; if (!(T = (BiTNode*)malloc(sizeof(BiTNode))))return ERROR; T-&gt;data = ch; CreateBiTree(T-&gt;lchild); CreateBiTree(T-&gt;rchild); &#125; return OK;&#125;int GetLevesNum(BiTree T) &#123; if (!T)return 0; else if (!T-&gt;lchild &amp;&amp; !T-&gt;rchild)return 1; else return GetLevesNum(T-&gt;lchild) + GetLevesNum(T-&gt;rchild);&#125;int GetNonlevesNum(BiTree T) &#123; if (!T || (!T-&gt;lchild &amp;&amp; !T-&gt;rchild))return 0; else return GetNonlevesNum(T-&gt;lchild) + GetNonlevesNum(T-&gt;rchild) + 1;&#125;int GetAllNum(BiTree T) &#123; if (!T)return 0; else return GetAllNum(T-&gt;lchild) + GetAllNum(T-&gt;rchild) + 1;&#125;int Depth(BiTree T) &#123; int hl, hr; if (!T)return 0; if (T &amp;&amp; (!T-&gt;lchild &amp;&amp; !T-&gt;rchild))return 1; else &#123; hl = Depth(T-&gt;lchild); hr = Depth(T-&gt;rchild); if (hl &gt; hr)return hl + 1; else return hr + 1; &#125;&#125;Status SearchFromTree(BiTree T, TElemType value) &#123; if (T) &#123; if (T-&gt;data == value) &#123; return OK; &#125; else &#123; return SearchFromTree(T-&gt;lchild, value) || SearchFromTree(T-&gt;rchild, value); &#125; &#125; return ERROR;&#125;Status GetAllPath(BiTree T, BiTree *path, int pathLen) &#123; if (!T) return OK; path[pathLen] = T; pathLen++; if (!T-&gt;lchild &amp;&amp; !T-&gt;rchild) &#123; for (int i = 0; i &lt; pathLen; i++) cout &lt;&lt; path[i]-&gt;data; cout &lt;&lt; endl; &#125; else &#123; GetAllPath(T-&gt;lchild, path, pathLen); GetAllPath(T-&gt;rchild, path, pathLen); &#125; return OK;&#125;Status OutputAllPath(BiTree T) &#123; BiTree *path = (BiTree*)malloc(Depth(T) * sizeof(BiTree)); GetAllPath(T, path, 0); return OK;&#125; 1.3赫夫曼树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788struct HTNode &#123; // 树中结点的结构 unsigned int weight; unsigned int parent, lchild, rchild;&#125;;struct HTCode &#123; char data; // 待编码的字符 int weight; // 字符的权值 char *code; // 字符的编码 &#125;;void Init(HTCode *hc, int n) &#123; // 初始化，读入待编码字符的个数n，从键盘输入n个字符和n个权值 int i; cout &lt;&lt; "请输入" &lt;&lt; n &lt;&lt; " 个字符" &lt;&lt; endl; for (i = 1; i &lt;= n; ++i) cin &gt;&gt; hc[i].data; cout &lt;&lt; "请按顺序输入" &lt;&lt; n &lt;&lt; "个字符的权重" &lt;&lt; endl; for (i = 1; i &lt;= n; ++i) cin &gt;&gt; hc[i].weight;&#125;void Select(HTNode *ht, int k, int &amp;s1, int &amp;s2) &#123; // ht[1...k]中选择parent为0，并且weight最小的两个结点，其序号由指针变量s1，s2指示 int i; for (i = 1; i &lt;= k &amp;&amp; ht[i].parent != 0; ++i) &#123; ; ; &#125; s1 = i; for (i = 1; i &lt;= k; ++i) &#123; if (ht[i].parent == 0 &amp;&amp; ht[i].weight&lt;ht[s1].weight) s1 = i; &#125; for (i = 1; i &lt;= k; ++i) &#123; if (ht[i].parent == 0 &amp;&amp; i != s1) break; &#125; s2 = i; for (i = 1; i &lt;= k; ++i) &#123; if (ht[i].parent == 0 &amp;&amp; i != s1 &amp;&amp; ht[i].weight&lt;ht[s2].weight) s2 = i; &#125;&#125;void HuffmanCoding(HTNode *ht, HTCode *hc, int n) &#123; // 构造Huffman树ht，并求出n个字符的编码 char *cd = (char*)malloc(n * sizeof(char)); int i, m, c, f, s1, s2, start; m = 2 * n - 1; for (i = 1; i &lt;= m; ++i) &#123; if (i &lt;= n) ht[i].weight = hc[i].weight; else ht[i].weight = 0; ht[i].parent = ht[i].lchild = ht[i].rchild = 0; &#125; for (i = n + 1; i &lt;= m; ++i) &#123; Select(ht, i - 1, s1, s2); ht[s1].parent = i; ht[s2].parent = i; ht[i].lchild = s1; ht[i].rchild = s2; ht[i].weight = ht[s1].weight + ht[s2].weight; &#125; cd[n - 1] = '\0'; for (i = 1; i &lt;= n; ++i) &#123; start = n - 1; for (c = i, f = ht[i].parent; f; c = f, f = ht[f].parent) &#123; if (ht[f].lchild == c) cd[--start] = '0'; else cd[--start] = '1'; &#125; hc[i].code = (char*)malloc((n - start + 1) * sizeof(char)); strcpy(hc[i].code, &amp;cd[start]); &#125;&#125;int main()&#123; int i, n; HTNode *ht; HTCode *hc; cout &lt;&lt; "请输入字符个数 n = "; cin &gt;&gt; n; hc = (HTCode*)malloc((n + 1) * sizeof(HTCode)); ht = (HTNode *)malloc((2 * n) * sizeof(HTNode)); Init(hc, n); // 初始化 HuffmanCoding(ht, hc, n); // 构造Huffman树，并形成字符的编码 cout &lt;&lt; endl; for (i = 1; i &lt;= n; ++i) cout &lt;&lt; hc[i].data &lt;&lt; "-----" &lt;&lt; hc[i].code &lt;&lt; endl; return 0;&#125; 2.图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816typedef int Status;#define MAX_VERTEX_NUM 20 //最大顶点个数typedef char VertexType; //顶点类型typedef int InfoType; //边的信息 权重typedef int VRType; //顶点关系，无权图中的邻接与否，带权图中的权值typedef int VisitIf; //访问标志 0 未访问 &gt;0 已访问typedef int GraphKind; //&#123;有向图=0，有向网=1，无向图=2，无向网=3&#125;////图的数组表示“邻接矩阵”#define INFINITY INT_MAX //最大值typedef struct ArcCell &#123; VRType adj; //VRType是顶点关系类型。对于无权图，用1或0表示相邻否；对带权图，则为权值类型。 char * info;//该弧相关信息的指针&#125;ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];//邻接矩阵typedef struct &#123; VertexType vexs[MAX_VERTEX_NUM]; //顶点向量 VisitIf visited[MAX_VERTEX_NUM]; AdjMatrix arcs; //邻接矩阵 int vexnum, arcnum; //图的当前顶点数和弧数 GraphKind kind; //图的种类标志&#125;MGraph;Status CreateGraph(MGraph &amp;G);//邻接矩阵建图int LocateVex(MGraph G, VertexType u);//确认位置VertexType FirstAdjVex(MGraph G, VertexType v);//返回v的第一个邻接顶点。VertexType NextAdjVex(MGraph G, VertexType v, VertexType w);//返回v的（相对于w的）下一个邻接顶点。Status CreateDG(MGraph &amp;G);//邻接矩阵建有向图Status CreateDN(MGraph &amp;G);//邻接矩阵建有向网Status CreateUDG(MGraph &amp;G);//邻接矩阵建无向图Status CreateUDN(MGraph &amp;G);//邻接矩阵建无向网Status DFSTraverse(MGraph G, Status(*Visit)(VertexType));//对图进行深度优先遍历。Status BFSTraverse(MGraph G, Status(*Visit)(VertexType));//对图进行广度优先遍历。typedef struct &#123; VertexType adjvex; VRType lowcost;&#125;ClosEdge;typedef struct &#123; VertexType *adjvex; int len;&#125;VexSet;typedef struct &#123; int i, j; VRType adj;&#125;ArcSet;Status MiniSpanTree_PRIM(MGraph G, VertexType u);//用普里姆算法从第u个顶点出发构造网G的最小生成树T，输出T的各条边Status MiniSpanTree_KRUSKAL(MGraph G);//用克鲁斯卡尔算法构造网G的最小生成树T，输出T的各条边////图的邻接表表示typedef struct ArcNode &#123; int adjvex; //该弧所指向的顶点的位置 struct ArcNode *nextarc; //指向下一条弧的指针 InfoType *info; //该弧相关信息的指针(如权值)&#125;ArcNode;typedef struct VNode &#123; VertexType data; //顶点信息 ArcNode *firstarc; //指向第一条依附该顶点的弧的指针&#125;VNode, AdjList[MAX_VERTEX_NUM];//头结点结构typedef struct &#123; AdjList vexs; VisitIf visited[MAX_VERTEX_NUM]; int vexnum, arcnum; //图的当前顶点数和弧数 int kind; //图的种类标志&#125;ALGraph; //图的结构Status InsertArcToGraph(ALGraph &amp;G, int i, ArcNode *u);//将边插入Status CreateGraph(ALGraph &amp;G);//邻接矩阵建图int LocateVex(ALGraph G, VertexType u);//确认位置VertexType FirstAdjVex(ALGraph G, VertexType v);//返回v的第一个邻接顶点。VertexType NextAdjVex(ALGraph G, VertexType v, VertexType w);//返回v的（相对于w的）下一个邻接顶点。Status CreateDG(ALGraph &amp;G);//邻接表建有向图Status CreateDN(ALGraph &amp;G);//邻接表建有向网Status CreateUDG(ALGraph &amp;G);//邻接表建无向图Status CreateUDN(ALGraph &amp;G);//邻接表建无向网Status DFSTraverse(ALGraph G, Status(*Visit)(VertexType));//对图进行深度优先遍历。Status BFSTraverse(ALGraph G, Status(*Visit)(VertexType));//对图进行广度优先遍历。////有向图的十字链表表示typedef struct ArcBox &#123; int tailvex, headvex; ArcBox *hlink, *tlink; InfoType *info;&#125;ArcBox;typedef struct VexNode &#123; VertexType data; ArcBox *firstin, *firstout;&#125;VexNode;typedef struct &#123; VexNode xlist[MAX_VERTEX_NUM]; VisitIf visited[MAX_VERTEX_NUM]; int vexnum, arcnum;&#125;OLGraph;Status CreateGraph(OLGraph &amp;G);//十字链表建图Status CreateDG(OLGraph &amp;G);//十字链表建有向图int LocateVex(OLGraph G, VertexType u);//确认位置VertexType FirstAdjVex(OLGraph G, VertexType v);//返回v的第一个邻接顶点。VertexType NextAdjVex(OLGraph G, VertexType v, VertexType w);//返回v的（相对于w的）下一个邻接顶点。Status DFSTraverse(OLGraph G, Status(*Visit)(VertexType));//对图进行深度优先遍历。Status BFSTraverse(OLGraph G, Status(*Visit)(VertexType));//对图进行广度优先遍历。////无向图的邻接多重表表示typedef struct EBox &#123; VisitIf mark; //访问标记 int ivex, jvex; //该边依附的两个顶点的位置 EBox *ilink, *jlink; //分别指向依附这两个顶点的下一条边 InfoType *info; //该边信息指针&#125;EdgeBox;typedef struct VexBox &#123; VertexType data; EdgeBox *firstedge; //指向第一条依附该顶点的边&#125;VexBox;typedef struct &#123; VisitIf visited[MAX_VERTEX_NUM]; VexBox adjmulist[MAX_VERTEX_NUM]; int vexnum, edgenum; //无向图的当前顶点数和边数&#125;AMLGraph;Status CreateGraph(AMLGraph &amp;G);//邻接多重表建图Status CreateUDG(AMLGraph &amp;G);//邻接多重表建无向图int LocateVex(AMLGraph G, VertexType u);//确认位置VertexType FirstAdjVex(AMLGraph G, VertexType v);//返回v的第一个邻接顶点。VertexType NextAdjVex(AMLGraph G, VertexType v, VertexType w);//返回v的（相对于w的）下一个邻接顶点。Status DFSTraverse(AMLGraph G, Status(*Visit)(VertexType));//对图进行深度优先遍历。Status BFSTraverse(AMLGraph G, Status(*Visit)(VertexType));//对图进行广度优先遍历。Status CreateGraph(MGraph &amp;G) &#123; cout &lt;&lt; "请选择要创建的图的类型：" &lt;&lt; endl &lt;&lt; "有向图\t0\n有向网\t1\n无向图\t2\n无向网\t3\n"; cin &gt;&gt; G.kind; switch (G.kind) &#123; case 0:return CreateDG(G); case 1:return CreateDN(G); case 2:return CreateUDG(G); case 3:return CreateUDN(G); default:return ERROR; &#125;&#125;int LocateVex(MGraph G, VertexType u) &#123; for (int i = 0; i &lt; G.vexnum; i++) if (G.vexs[i] == u)return i; return -1;&#125;VertexType FirstAdjVex(MGraph G, VertexType v) &#123; int i = LocateVex(G, v), j; if (G.kind == 0 || G.kind == 2) for (j = 0; j &lt; G.vexnum &amp;&amp; G.arcs[i][j].adj == 0; j++); else if (G.kind == 1 || G.kind == 3) for (j = 0; j &lt; G.vexnum &amp;&amp; G.arcs[i][j].adj == INFINITY; j++); if (j == G.vexnum)return -1; return G.vexs[j];&#125;VertexType NextAdjVex(MGraph G, VertexType v, VertexType w) &#123; int i = LocateVex(G, v), j = LocateVex(G, w) + 1; if (G.kind == 0 || G.kind == 2) for (; j &lt; G.vexnum &amp;&amp; G.arcs[i][j].adj == 0; j++); else if (G.kind == 1 || G.kind == 3) for (; j &lt; G.vexnum &amp;&amp; G.arcs[i][j].adj == INFINITY; j++); if (j == G.vexnum)return -1; return G.vexs[j];&#125;Status CreateDG(MGraph &amp;G) &#123; int i, j, k; VertexType v1, v2; cout &lt;&lt; "请输入顶点的数目："; cin &gt;&gt; G.vexnum; cout &lt;&lt; "请输入弧的数目："; cin &gt;&gt; G.arcnum; for (i = 0; i&lt;G.vexnum; i++) &#123; cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个顶点"; cin &gt;&gt; G.vexs[i]; &#125; for (i = 0; i&lt;G.vexnum; ++i) for (j = 0; j&lt;G.vexnum; ++j) &#123; G.arcs[i][j].adj = 0; G.arcs[i][j].info = NULL; &#125; for (k = 0; k&lt;G.arcnum; ++k) &#123; cout &lt;&lt; "请输入起始点 (字符)："; cin &gt;&gt; v1; cout &lt;&lt; "请输入终止点 (字符)："; cin &gt;&gt; v2; i = LocateVex(G, v1); j = LocateVex(G, v2); G.arcs[i][j].adj = 1; &#125; return OK;&#125;Status CreateDN(MGraph &amp;G) &#123; int i, j, k, w; VertexType v1, v2; cout &lt;&lt; "请输入顶点的数目："; cin &gt;&gt; G.vexnum; cout &lt;&lt; "请输入弧的数目："; cin &gt;&gt; G.arcnum; for (i = 0; i&lt;G.vexnum; i++) &#123; cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个顶点"; cin &gt;&gt; G.vexs[i]; &#125; for (i = 0; i&lt;G.vexnum; ++i) for (j = 0; j&lt;G.vexnum; ++j) &#123; G.arcs[i][j].adj = INFINITY; G.arcs[i][j].info = NULL; &#125; for (k = 0; k&lt;G.arcnum; ++k) &#123; cout &lt;&lt; "请输入起始点 (字符)："; cin &gt;&gt; v1; cout &lt;&lt; "请输入终止点 (字符)："; cin &gt;&gt; v2; cout &lt;&lt; "请输入权值："; cin &gt;&gt; w; i = LocateVex(G, v1); j = LocateVex(G, v2); G.arcs[i][j].adj = w; &#125; return OK;&#125;Status CreateUDG(MGraph &amp;G) &#123; int i, j, k; VertexType v1, v2; cout &lt;&lt; "请输入顶点的数目："; cin &gt;&gt; G.vexnum; cout &lt;&lt; "请输入边的数目："; cin &gt;&gt; G.arcnum; for (i = 0; i&lt;G.vexnum; i++) &#123; cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个顶点"; cin &gt;&gt; G.vexs[i]; &#125; for (i = 0; i&lt;G.vexnum; ++i) for (j = 0; j&lt;G.vexnum; ++j) &#123; G.arcs[i][j].adj = 0; G.arcs[i][j].info = NULL; &#125; for (k = 0; k&lt;G.arcnum; ++k) &#123; cout &lt;&lt; "请输入起始点 (字符)："; cin &gt;&gt; v1; cout &lt;&lt; "请输入终止点 (字符)："; cin &gt;&gt; v2; i = LocateVex(G, v1); j = LocateVex(G, v2); G.arcs[i][j].adj = 1; G.arcs[j][i].adj = G.arcs[i][j].adj; &#125; return OK;&#125;Status CreateUDN(MGraph &amp;G) &#123; int i, j, k, w; VertexType v1, v2; cout &lt;&lt; "请输入顶点的数目："; cin &gt;&gt; G.vexnum; cout &lt;&lt; "请输入边的数目："; cin &gt;&gt; G.arcnum; for (i = 0; i&lt;G.vexnum; i++) &#123; cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个顶点 (字符)"; cin &gt;&gt; G.vexs[i]; &#125; for (i = 0; i&lt;G.vexnum; ++i) for (j = 0; j&lt;G.vexnum; ++j) &#123; G.arcs[i][j].adj = INFINITY; G.arcs[i][j].info = NULL; &#125; for (k = 0; k&lt;G.arcnum; ++k) &#123; cout &lt;&lt; "请输入起始点 (字符)："; cin &gt;&gt; v1; cout &lt;&lt; "请输入终止点 (字符)："; cin &gt;&gt; v2; cout &lt;&lt; "请输入权值："; cin &gt;&gt; w; i = LocateVex(G, v1); j = LocateVex(G, v2); G.arcs[i][j].adj = w; G.arcs[j][i].adj = G.arcs[i][j].adj; &#125; return OK;&#125;void DFS(MGraph &amp;G, VertexType v, Status(*Visit)(VertexType)) &#123; G.visited[LocateVex(G, v)] = 1; Visit(v); for (VertexType w = FirstAdjVex(G, v); w &gt;= 0; w = NextAdjVex(G, v, w)) if (G.visited[LocateVex(G, w)] == 0) DFS(G, w, Visit);&#125;Status DFSTraverse(MGraph G, Status(*Visit)(VertexType)) &#123; cout &lt;&lt; "图的深度优先遍历："; for (int i = 0; i &lt; G.vexnum; ++i) G.visited[i] = 0; for (int v = 0; v &lt; G.vexnum; ++v) if (G.visited[v] == 0) DFS(G, G.vexs[v], Visit); cout &lt;&lt; endl; return OK;&#125;Status BFSTraverse(MGraph G, Status(*Visit)(VertexType)) &#123; cout &lt;&lt; "图的广度优先遍历："; VertexType v, w; queue&lt;VertexType&gt; Q; VertexType u; for (int i = 0; i&lt;G.vexnum; ++i) G.visited[i] = 0; for (int i = 0; i &lt; G.vexnum; ++i) if (G.visited[i] == 0) &#123; v = G.vexs[i]; G.visited[i] = 1; Visit(v); Q.push(v); while (!Q.empty()) &#123; u = Q.front(); Q.pop(); for (w = FirstAdjVex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w)) if (G.visited[LocateVex(G, w)] == 0) &#123; G.visited[LocateVex(G, w)] = 1; Visit(w); Q.push(w); &#125; &#125; &#125; cout &lt;&lt; endl; return OK;&#125;int minimum(ClosEdge *clos, int num) &#123; int min, tag = 0; for(int i = 0;i &lt; num;i++)&#123; if (clos[i].lowcost &gt; 0) &#123; if (tag == 0) tag = 1, min = i; else min = clos[i].lowcost &lt; clos[min].lowcost ? i : min; &#125; &#125; return min;&#125;Status MiniSpanTree_PRIM(MGraph G, VertexType u) &#123; cout &lt;&lt; "普里姆算法生成最小生成树：" &lt;&lt; endl; ClosEdge closedge[MAX_VERTEX_NUM]; int i, j, k; k = LocateVex(G, u); for (j = 0; j&lt;G.vexnum; ++j) &#123; if (j != k) &#123; closedge[j].adjvex = u; closedge[j].lowcost = G.arcs[k][j].adj; &#125; &#125; closedge[k].lowcost = 0; for (i = 1; i&lt;G.vexnum; ++i) &#123; k = minimum(closedge, G.vexnum); cout &lt;&lt; closedge[k].adjvex &lt;&lt; ' ' &lt;&lt; G.vexs[k] &lt;&lt; endl; closedge[k].lowcost = 0; for (j = 0; j&lt;G.vexnum; ++j) if (G.arcs[k][j].adj &lt; closedge[j].lowcost) &#123; closedge[j].adjvex = G.vexs[k]; closedge[j].lowcost = G.arcs[k][j].adj; &#125; &#125; return OK;&#125;void UnionSet(VexSet *vex,int i,int j, int num) &#123; VexSet *v = new VexSet; v-&gt;len = vex[i].len + vex[j].len; v-&gt;adjvex = new VertexType[v-&gt;len]; for (int k = 0; k &lt; v-&gt;len; k++) &#123; if (k &lt; vex[i].len)v-&gt;adjvex[k] = vex[i].adjvex[k]; else v-&gt;adjvex[k] = vex[j].adjvex[k - vex[i].len]; &#125; for (int k = 0; k &lt; num; k++) &#123; if (k != i &amp;&amp; k != j) &#123; if (vex[k].adjvex == vex[i].adjvex || vex[k].adjvex == vex[j].adjvex) vex[k].adjvex = v-&gt;adjvex; &#125; &#125; vex[i].adjvex = vex[j].adjvex = v-&gt;adjvex;&#125;int comp(ArcSet a1, ArcSet a2) &#123; return a1.adj &lt; a2.adj;&#125;Status MiniSpanTree_KRUSKAL(MGraph G) &#123; cout &lt;&lt; "克鲁斯卡尔算法生成最小生成树：" &lt;&lt; endl; VexSet *vex = new VexSet[G.vexnum]; ArcSet *arc = new ArcSet[G.arcnum]; int i, j, k = 0, l; for (i = 0; i &lt; G.vexnum; i++) for (j = i; j &lt; G.vexnum; j++) if (G.arcs[i][j].adj &gt; 0 &amp;&amp; G.arcs[i][j].adj != INFINITY) &#123; arc[k].i = i; arc[k].j = j; arc[k].adj = G.arcs[i][j].adj; k++; &#125; sort(arc, arc + G.arcnum, comp); for (i = 0; i &lt; G.vexnum; i++) &#123; vex[i].len = 1; vex[i].adjvex = new VertexType; *(vex[i].adjvex) = G.vexs[i]; &#125; for (l = 0,k = 1; k &lt; G.vexnum; k++) &#123; i = arc[l].i; j = arc[l].j; l++; if (vex[i].adjvex != vex[j].adjvex) &#123; cout &lt;&lt; G.vexs[i] &lt;&lt; " " &lt;&lt; G.vexs[j] &lt;&lt; endl; UnionSet(vex, i, j, G.vexnum); &#125; else k--; &#125; return OK;&#125;Status CreateGraph(ALGraph &amp; G) &#123; cout &lt;&lt; "请选择要创建的图的类型：" &lt;&lt; endl &lt;&lt; "有向图\t0\n有向网\t1\n无向图\t2\n无向网\t3\n"; cin &gt;&gt; G.kind; switch (G.kind) &#123; case 0: return CreateDG(G); case 1: return CreateDN(G); case 2: return CreateUDG(G); case 3: return CreateUDN(G); default:return ERROR; &#125; return OK;&#125;Status InsertArcToGraph(ALGraph &amp;G, int i, ArcNode *u) &#123; ArcNode *p = G.vexs[i].firstarc; if (!p) &#123; u-&gt;nextarc = p; G.vexs[i].firstarc = u; &#125; else&#123; while (p-&gt;nextarc &amp;&amp; p-&gt;nextarc-&gt;adjvex &lt; u-&gt;adjvex)p = p-&gt;nextarc; u-&gt;nextarc = p-&gt;nextarc; p-&gt;nextarc = u; &#125; return OK;&#125;int LocateVex(ALGraph G, VertexType u) &#123; for (int i = 0; i &lt; G.vexnum; i++) if (G.vexs[i].data == u)return i; return -1;&#125;VertexType FirstAdjVex(ALGraph G, VertexType v) &#123; int i = LocateVex(G, v); if (G.vexs[i].firstarc == NULL)return -1; return G.vexs[G.vexs[i].firstarc-&gt;adjvex].data;&#125;VertexType NextAdjVex(ALGraph G, VertexType v, VertexType w) &#123; int i = LocateVex(G, v); ArcNode *p = G.vexs[i].firstarc; while (p) &#123; if (G.vexs[p-&gt;adjvex].data == w)break; p = p-&gt;nextarc; &#125; if (p-&gt;nextarc == NULL)return -1; return G.vexs[p-&gt;nextarc-&gt;adjvex].data;&#125;Status CreateDG(ALGraph &amp; G) &#123; int i, j, k; VertexType v1, v2; ArcNode *p; cout &lt;&lt; "请输入顶点的数目："; cin &gt;&gt; G.vexnum; cout &lt;&lt; "请输入边的数目："; cin &gt;&gt; G.arcnum; for (i = 0; i &lt; G.vexnum; i++) &#123; cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个顶点 (字符)"; cin &gt;&gt; G.vexs[i].data; G.vexs[i].firstarc = NULL; &#125; for (k = 0; k&lt;G.arcnum; k++) &#123; cout &lt;&lt; "请输入起始点 (字符)："; cin &gt;&gt; v1; cout &lt;&lt; "请输入终止点 (字符)："; cin &gt;&gt; v2; i = LocateVex(G, v1); j = LocateVex(G, v2); p = (ArcNode*)malloc(sizeof(ArcNode)); p-&gt;adjvex = j; p-&gt;info = NULL; InsertArcToGraph(G, i, p); &#125; return OK;&#125;Status CreateDN(ALGraph &amp; G) &#123; int i, j, k, w; VertexType v1, v2; ArcNode *p; cout &lt;&lt; "请输入顶点的数目："; cin &gt;&gt; G.vexnum; cout &lt;&lt; "请输入边的数目："; cin &gt;&gt; G.arcnum; for (i = 0; i &lt; G.vexnum; i++) &#123; cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个顶点 (字符)"; cin &gt;&gt; G.vexs[i].data; G.vexs[i].firstarc = NULL; &#125; for (k = 0; k&lt;G.arcnum; k++) &#123; cout &lt;&lt; "请输入起始点 (字符)："; cin &gt;&gt; v1; cout &lt;&lt; "请输入终止点 (字符)："; cin &gt;&gt; v2; cout &lt;&lt; "请输入权值："; cin &gt;&gt; w; i = LocateVex(G, v1); j = LocateVex(G, v2); p = (ArcNode*)malloc(sizeof(ArcNode)); p-&gt;adjvex = j; p-&gt;info = new int(); *(p-&gt;info) = w; InsertArcToGraph(G, i, p); &#125; return OK;&#125;Status CreateUDG(ALGraph &amp; G) &#123; int i, j, k; VertexType v1, v2; ArcNode *p; cout &lt;&lt; "请输入顶点的数目："; cin &gt;&gt; G.vexnum; cout &lt;&lt; "请输入边的数目："; cin &gt;&gt; G.arcnum; for (i = 0; i &lt; G.vexnum; i++) &#123; cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个顶点 (字符)"; cin &gt;&gt; G.vexs[i].data; G.vexs[i].firstarc = NULL; &#125; for (k = 0; k&lt;G.arcnum; k++) &#123; cout &lt;&lt; "请输入起始点 (字符)："; cin &gt;&gt; v1; cout &lt;&lt; "请输入终止点 (字符)："; cin &gt;&gt; v2; i = LocateVex(G, v1); j = LocateVex(G, v2); p = (ArcNode*)malloc(sizeof(ArcNode)); p-&gt;adjvex = j; p-&gt;info = NULL; InsertArcToGraph(G, i, p); p = (ArcNode*)malloc(sizeof(ArcNode)); p-&gt;adjvex = i; p-&gt;info = NULL; InsertArcToGraph(G, j, p); &#125; return OK;&#125;Status CreateUDN(ALGraph &amp; G) &#123; int i, j, k, w; VertexType v1, v2; ArcNode *p; cout &lt;&lt; "请输入顶点的数目："; cin &gt;&gt; G.vexnum; cout &lt;&lt; "请输入边的数目："; cin &gt;&gt; G.arcnum; for (i = 0; i &lt; G.vexnum; i++) &#123; cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个顶点 (字符)"; cin &gt;&gt; G.vexs[i].data; G.vexs[i].firstarc = NULL; &#125; for (k = 0; k&lt;G.arcnum; k++) &#123; cout &lt;&lt; "请输入起始点 (字符)："; cin &gt;&gt; v1; cout &lt;&lt; "请输入终止点 (字符)："; cin &gt;&gt; v2; cout &lt;&lt; "请输入权值："; cin &gt;&gt; w; i = LocateVex(G, v1); j = LocateVex(G, v2); p = (ArcNode*)malloc(sizeof(ArcNode)); p-&gt;adjvex = j; p-&gt;info = new int(); *(p-&gt;info) = w; InsertArcToGraph(G, i, p); p = (ArcNode*)malloc(sizeof(ArcNode)); p-&gt;adjvex = i; p-&gt;info = new int(); *(p-&gt;info) = w; InsertArcToGraph(G, j, p); &#125; return OK;&#125;void DFS(ALGraph &amp;G, VertexType v, Status(*Visit)(VertexType)) &#123; G.visited[LocateVex(G, v)] = 1; Visit(v); for (VertexType w = FirstAdjVex(G, v); w &gt;= 0; w = NextAdjVex(G, v, w)) if (G.visited[LocateVex(G, w)] == 0) DFS(G, w, Visit);&#125;Status DFSTraverse(ALGraph G, Status(*Visit)(VertexType)) &#123; cout &lt;&lt; "图的深度优先遍历："; for (int i = 0; i &lt; G.vexnum; ++i) G.visited[i] = 0; for (int v = 0; v &lt; G.vexnum; ++v) if (G.visited[v] == 0) DFS(G, G.vexs[v].data, Visit); cout &lt;&lt; endl; return OK;&#125;Status BFSTraverse(ALGraph G, Status(*Visit)(VertexType)) &#123; cout &lt;&lt; "图的广度优先遍历："; VertexType v, w; queue&lt;VertexType&gt; Q; VertexType u; for (int i = 0; i&lt;G.vexnum; ++i) G.visited[i] = 0; for (int i = 0; i &lt; G.vexnum; ++i) if (G.visited[i] == 0) &#123; v = G.vexs[i].data; G.visited[i] = 1; Visit(v); Q.push(v); while (!Q.empty()) &#123; u = Q.front(); Q.pop(); for (w = FirstAdjVex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w)) if (G.visited[LocateVex(G, w)] == 0) &#123; G.visited[LocateVex(G, w)] = 1; Visit(w); Q.push(w); &#125; &#125; &#125; cout &lt;&lt; endl; return OK;&#125;Status CreateGraph(OLGraph &amp;G) &#123; return CreateDG(G);&#125;Status CreateDG(OLGraph &amp; G) &#123; int i, j, k; VertexType v1, v2; ArcBox *p; cout &lt;&lt; "请输入顶点的数目："; cin &gt;&gt; G.vexnum; cout &lt;&lt; "请输入边的数目："; cin &gt;&gt; G.arcnum; for (i = 0; i &lt; G.vexnum; ++i) &#123; cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个顶点 (字符)"; cin &gt;&gt; G.xlist[i].data; G.xlist[i].firstin = G.xlist[i].firstout = NULL; &#125; for (k = 0; k &lt; G.arcnum; ++k) &#123; cout &lt;&lt; "请输入起始点 (字符)："; cin &gt;&gt; v1; cout &lt;&lt; "请输入终止点 (字符)："; cin &gt;&gt; v2; i = LocateVex(G, v1); j = LocateVex(G, v2); p = (ArcBox *)malloc(sizeof(ArcBox)); p-&gt;headvex = i; p-&gt;tailvex = j; p-&gt;hlink = G.xlist[i].firstout; p-&gt;tlink = G.xlist[j].firstin; p-&gt;info = NULL; G.xlist[j].firstin = G.xlist[i].firstout = p; &#125; return OK;&#125;int LocateVex(OLGraph G, VertexType u) &#123; for (int i = 0; i &lt; G.vexnum; i++) if (G.xlist[i].data == u)return i; return -1;&#125;VertexType FirstAdjVex(OLGraph G, VertexType v) &#123; int i = LocateVex(G, v); if (G.xlist[i].firstout == NULL)return -1; return G.xlist[G.xlist[i].firstout-&gt;tailvex].data;&#125;VertexType NextAdjVex(OLGraph G, VertexType v, VertexType w) &#123; int i = LocateVex(G, v); ArcBox *p = G.xlist[i].firstout; while (p) &#123; if (G.xlist[p-&gt;tailvex].data == w)break; p = p-&gt;hlink; &#125; if (p-&gt;hlink == NULL)return -1; return G.xlist[p-&gt;hlink-&gt;tailvex].data;&#125;void DFS(OLGraph &amp;G, VertexType v, Status(*Visit)(VertexType)) &#123; G.visited[LocateVex(G, v)] = 1; Visit(v); for (VertexType w = FirstAdjVex(G, v); w &gt;= 0; w = NextAdjVex(G, v, w)) if (G.visited[LocateVex(G, w)] == 0) DFS(G, w, Visit);&#125;Status DFSTraverse(OLGraph G, Status(*Visit)(VertexType)) &#123; cout &lt;&lt; "图的深度优先遍历："; for (int i = 0; i &lt; G.vexnum; ++i) G.visited[i] = 0; for (int v = 0; v &lt; G.vexnum; ++v) if (G.visited[v] == 0) DFS(G, G.xlist[v].data, Visit); cout &lt;&lt; endl; return OK;&#125;Status BFSTraverse(OLGraph G, Status(*Visit)(VertexType)) &#123; cout &lt;&lt; "图的广度优先遍历："; VertexType v, w; queue&lt;VertexType&gt; Q; VertexType u; for (int i = 0; i&lt;G.vexnum; ++i) G.visited[i] = 0; for (int i = 0; i &lt; G.vexnum; ++i) if (G.visited[i] == 0) &#123; v = G.xlist[i].data; G.visited[i] = 1; Visit(v); Q.push(v); while (!Q.empty()) &#123; u = Q.front(); Q.pop(); for (w = FirstAdjVex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w)) if (G.visited[LocateVex(G, w)] == 0) &#123; G.visited[LocateVex(G, w)] = 1; Visit(w); Q.push(w); &#125; &#125; &#125; cout &lt;&lt; endl; return OK;&#125;Status CreateGraph(AMLGraph &amp;G) &#123; return CreateUDG(G);&#125;Status CreateUDG(AMLGraph &amp; G) &#123; int i, j, k; VertexType v1, v2; EdgeBox *p; cout &lt;&lt; "请输入顶点的数目："; cin &gt;&gt; G.vexnum; cout &lt;&lt; "请输入边的数目："; cin &gt;&gt; G.edgenum; for (i = 0; i &lt; G.vexnum; i++) &#123; cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个顶点 (字符)"; cin &gt;&gt; G.adjmulist[i].data; G.adjmulist[i].firstedge = NULL; &#125; for (k = 0; k&lt;G.edgenum; k++) &#123; cout &lt;&lt; "请输入起始点 (字符)："; cin &gt;&gt; v1; cout &lt;&lt; "请输入终止点 (字符)："; cin &gt;&gt; v2; i = LocateVex(G, v1); j = LocateVex(G, v2); p = (EdgeBox*)malloc(sizeof(EdgeBox)); p-&gt;ivex = i; p-&gt;jvex = j; p-&gt;ilink = G.adjmulist[i].firstedge; p-&gt;jlink = G.adjmulist[j].firstedge; G.adjmulist[i].firstedge = p; G.adjmulist[j].firstedge = p; p-&gt;info = NULL; &#125; return OK;&#125;int LocateVex(AMLGraph G, VertexType u) &#123; for (int i = 0; i &lt; G.vexnum; i++) if (G.adjmulist[i].data == u)return i; return -1;&#125;VertexType FirstAdjVex(AMLGraph G, VertexType v) &#123; int i = LocateVex(G, v); if (G.adjmulist[i].firstedge == NULL)return -1; if (G.adjmulist[i].firstedge-&gt;ivex == i) return G.adjmulist[G.adjmulist[i].firstedge-&gt;jvex].data; else return G.adjmulist[G.adjmulist[i].firstedge-&gt;ivex].data;&#125;VertexType NextAdjVex(AMLGraph G, VertexType v, VertexType w) &#123; int i = LocateVex(G, v), j; EdgeBox *p = G.adjmulist[i].firstedge; while (p) &#123; if (p-&gt;ivex == i) &#123; j = p-&gt;jvex; p = p-&gt;ilink; &#125; else &#123; j = p-&gt;ivex; p = p-&gt;jlink; &#125; if (G.adjmulist[j].data == w) break; &#125; if (p == NULL)return -1; if (p-&gt;ivex == i) return G.adjmulist[p-&gt;jvex].data; else return G.adjmulist[p-&gt;ivex].data;&#125;void DFS(AMLGraph &amp;G, VertexType v, Status(*Visit)(VertexType)) &#123; G.visited[LocateVex(G, v)] = 1; Visit(v); for (VertexType w = FirstAdjVex(G, v); w &gt;= 0; w = NextAdjVex(G, v, w)) if (G.visited[LocateVex(G, w)] == 0) DFS(G, w, Visit);&#125;Status DFSTraverse(AMLGraph G, Status(*Visit)(VertexType)) &#123; cout &lt;&lt; "图的深度优先遍历："; for (int i = 0; i &lt; G.vexnum; ++i) G.visited[i] = 0; for (int v = 0; v &lt; G.vexnum; ++v) if (G.visited[v] == 0) DFS(G, G.adjmulist[v].data, Visit); cout &lt;&lt; endl; return OK;&#125;Status BFSTraverse(AMLGraph G, Status(*Visit)(VertexType)) &#123; cout &lt;&lt; "图的广度优先遍历："; VertexType v, w; queue&lt;VertexType&gt; Q; VertexType u; for (int i = 0; i&lt;G.vexnum; ++i) G.visited[i] = 0; for (int i = 0; i &lt; G.vexnum; ++i) if (G.visited[i] == 0) &#123; v = G.adjmulist[i].data; G.visited[i] = 1; Visit(v); Q.push(v); while (!Q.empty()) &#123; u = Q.front(); Q.pop(); for (w = FirstAdjVex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w)) if (G.visited[LocateVex(G, w)] == 0) &#123; G.visited[LocateVex(G, w)] = 1; Visit(w); Q.push(w); &#125; &#125; &#125; cout &lt;&lt; endl; return OK;&#125; 散列储存结构哈希(Hash)表 特殊运算1.查找1234567891011121314151617181920212223242526272829303132333435363738typedef struct &#123; KeyType key;&#125;ElemType;#define EQ(a,b) ((a) == (b))#define LT(a,b) ((a) &lt; (b))#define LQ(a,b) ((a) &lt;= (b))typedef struct &#123; ElemType *elem; int length;&#125;SSTable;Status Create(SSTable &amp;ST, int n);int Search_Seq(SSTable ST, KeyType key);int Search_Bin(SSTable ST, KeyType key);Status Create(SSTable &amp;ST, int n) &#123; ST.elem = (ElemType*)malloc((n + 1) * sizeof(ElemType)); ST.length = n; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; "请顺序输入第" &lt;&lt; i &lt;&lt; "个元素:"; cin &gt;&gt; ST.elem[i].key; &#125; return OK;&#125;int Search_Seq(SSTable ST, KeyType key) &#123; int i; ST.elem[0].key = key; for (i = ST.length; !EQ(ST.elem[i].key, key); --i); return i;&#125;int Search_Bin(SSTable ST, KeyType key) &#123; int low = 1, high = ST.length, mid; while (low &lt;= high) &#123; mid = (low + high) / 2; if (EQ(key, ST.elem[mid].key)) return mid; else if (LT(key, ST.elem[mid].key)) high = mid - 1; else low = mid + 1; &#125; return 0;&#125; 2.排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#define EQ(a,b) ((a) == (b))#define LT(a,b) ((a) &lt; (b))#define LQ(a,b) ((a) &lt;= (b))#define MT(a,b) ((a) &gt; (b))#define MQ(a,b) ((a) &gt;= (b))typedef struct &#123;&#125;InfoType;typedef struct &#123; KeyType key; InfoType otherinfo;&#125;RedType;typedef struct &#123; RedType *r; int length;&#125;SqList;Status CreateList(SqList &amp;L) &#123; cout &lt;&lt; "请输入顺序表的长度" &lt;&lt; endl; cin &gt;&gt; L.length; L.r = new RedType[L.length + 1]; for (int i = 1; i &lt;= L.length; i++) &#123; cout &lt;&lt; "请输入第" &lt;&lt; i &lt;&lt; "个元素的关键字："; cin &gt;&gt; L.r[i].key; &#125; return OK;&#125;void PrintList(SqList L) &#123; for (int i = 1; i &lt;= L.length; i++) cout &lt;&lt; L.r[i].key &lt;&lt; " "; cout &lt;&lt; endl;&#125;Status InsertSort(SqList &amp;L) &#123; int i, j, n; n = 0; for (i = 2; i &lt;= L.length; i++) &#123; if (LT(L.r[i].key, L.r[i - 1].key)) &#123; L.r[0] = L.r[i]; L.r[i] = L.r[i - 1]; for (j = i - 2; LT(L.r[0].key, L.r[j].key); j--) L.r[j + 1] = L.r[j]; L.r[j + 1] = L.r[0]; &#125; cout &lt;&lt; "第" &lt;&lt; ++n &lt;&lt; "趟排序后" &lt;&lt; endl; PrintList(L); &#125; return OK;&#125;Status BubbleSort(SqList &amp;L) &#123; int i, j, k, n; k = L.length; n = 0; while (1) &#123; i = k; for (j = 1; j &lt; i; j++) &#123; if (LT(L.r[j + 1].key, L.r[j].key)) &#123; L.r[0] = L.r[j]; L.r[j] = L.r[j + 1]; L.r[j + 1] = L.r[0]; k = j; &#125; &#125; if (i == k)break; cout &lt;&lt; "第" &lt;&lt; ++n &lt;&lt; "趟排序后" &lt;&lt; endl; PrintList(L); &#125; return OK;&#125;int SelectMinKey(SqList L, int i) &#123; int j, min = i; for (j = i; j &lt;= L.length; j++) &#123; if (LT(L.r[j].key, L.r[min].key))min = j; &#125; return min;&#125;Status SelectSort(SqList &amp;L) &#123; int i, j; for (i = 1; i &lt; L.length; i++) &#123; j = SelectMinKey(L, i); if (i != j) &#123; L.r[0] = L.r[j]; L.r[j] = L.r[i]; L.r[i] = L.r[0]; &#125; cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "趟排序后" &lt;&lt; endl; PrintList(L); &#125; return OK;&#125;int Partition(SqList &amp;L, int low, int high) &#123; L.r[0] = L.r[low]; KeyType pivotkey = L.r[low].key; while (low &lt; high) &#123; while (low&lt;high&amp;&amp;MQ(L.r[high].key, pivotkey))--high; L.r[low] = L.r[high]; while (low&lt;high&amp;&amp;LQ(L.r[low].key, pivotkey))++low; L.r[high] = L.r[low]; &#125; L.r[low] = L.r[0]; return low;&#125;Status QSort(SqList &amp;L, int low, int high) &#123; static int num = 0; if (low &lt; high) &#123; int pivotloc = Partition(L, low, high); QSort(L, low, pivotloc - 1); QSort(L, pivotloc + 1, high); &#125; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "趟排序后" &lt;&lt; endl; PrintList(L); return OK;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础]]></title>
    <url>%2F2017%2F07%2F01%2FC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[C语言基础 变量 运算与运算符 输入与输出 程序结构 数组与字符串 函数 结构体与类 C语言标准库STL]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[控制台小游戏合集（持续更新）]]></title>
    <url>%2F2017%2F07%2F01%2F%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%90%88%E9%9B%86%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[近日为了做好游戏相关的准备，特地自行制作了几款控制台的小游戏，在以后的时间中，也会持续更新。 五子棋(鼠标下棋)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;string&gt;using namespace std;#define LEFT_CLICK FROM_LEFT_1ST_BUTTON_PRESSED#define RIGHT_CLICK RIGHTMOST_BUTTON_PRESSEDtypedef int GameState;#define PLAYING 0#define BLACKWIN 1#define WHITEWIN 2#define BLACK 1#define WHITE 2int ChessBoard[19][19];short Top = 3, Left = 6;char BlackChess[3] = "○";char WhiteChess[3] = "●";int Direct[8][2] = &#123; &#123; 1,1 &#125;, &#123; 1,0 &#125;, &#123; 1,-1 &#125;, &#123; 0,-1 &#125;, &#123; -1,-1 &#125;, &#123; -1,0 &#125;, &#123; -1,1 &#125;, &#123; 0,1 &#125;&#125;;//------------------控制台函数------------------------void curGotoXY(short x, short y);//光标移动COORD getMouseXY(DWORD clickType);//鼠标单击时的位置 clickType = LEFT_CLICK时为鼠标左键void HideCursor();void ClearScreen(); // 清屏void PrintInXY(short x, short y, char *str);//-----------------------函数-----------------------void ShowInfo(bool isBlack);void ClearCB();void DrawCB();void Game();GameState CheckWin(int x, int y);void Message(int whoWin);int main() &#123; HideCursor(); while(true)&#123; ClearScreen(); ClearCB(); DrawCB(); Game(); curGotoXY(0, 0); getchar(); &#125; return 0;&#125;void curGotoXY(short x, short y) &#123; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), &#123; x,y &#125;);&#125;COORD getMouseXY(DWORD clickType) &#123; INPUT_RECORD inRec; DWORD res; COORD pos; while (1) &#123; ReadConsoleInputW(GetStdHandle(STD_INPUT_HANDLE), &amp;inRec, 1, &amp;res); if (inRec.EventType == MOUSE_EVENT) &#123; pos = inRec.Event.MouseEvent.dwMousePosition; if (inRec.Event.MouseEvent.dwButtonState == clickType) break; &#125; &#125; return pos;&#125;void HideCursor() &#123; CONSOLE_CURSOR_INFO cursor_info = &#123; 1, 0 &#125;; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);&#125;void ClearScreen() &#123; CONSOLE_SCREEN_BUFFER_INFO bInfo; DWORD d; GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;bInfo); COORD home = &#123; 0, 0 &#125;; unsigned long size = bInfo.dwSize.X * bInfo.dwSize.Y; FillConsoleOutputCharacterW(GetStdHandle(STD_OUTPUT_HANDLE), 0, size, home, &amp;d);&#125;void PrintInXY(short x, short y, char * str) &#123; //DWORD d; curGotoXY(x, y); printf_s("%s", str); //WriteConsoleOutputCharacter(GetStdHandle(STD_OUTPUT_HANDLE), (LPCWSTR)str, strlen(str), &#123; x,y &#125;, &amp;d);&#125;void ShowInfo(bool isBlack) &#123; char * str; if (isBlack)str = "该黑棋下了"; else str = "该白棋下了"; PrintInXY(Left + 8, 2, str);&#125;void ClearCB() &#123; for (int i = 0; i &lt; 19; i++) for (int j = 0; j &lt; 19; j++) ChessBoard[i][j] = 0;&#125;void DrawCB() &#123; char * str; for (short i = 0; i &lt; 19; i++) &#123; for (short j = 0; j &lt; 19; j++) &#123; if (i == 0 &amp;&amp; j == 0) str = "╔"; else if (i == 0 &amp;&amp; j == 18) str = "╚"; else if (i == 18 &amp;&amp; j == 0) str = "╗"; else if (i == 18 &amp;&amp; j == 18) str = "╝"; else if (i == 0) str = "╠"; else if (i == 18) str = "╣"; else if (j == 0) str = "╦"; else if (j == 18) str = "╩"; else str = "╬"; PrintInXY(i * 2 + Left, j + Top, str); &#125; &#125; //═║╔╗╚╝╠╣╦╩╬○●&#125;void Game() &#123; int Winner; bool isBlack = true; ShowInfo(isBlack); int x = 0, y = 0; do &#123; if (isBlack) &#123; COORD pos = getMouseXY(LEFT_CLICK); x = (pos.X - Left) / 2, y = pos.Y - Top; if (x &gt; 18 || x &lt; 0 || y &gt; 18 || y &lt; 0) continue; if (ChessBoard[x][y] == 0) &#123; PrintInXY(x * 2 + Left, y + Top, BlackChess); ChessBoard[x][y] = BLACK; isBlack = !isBlack; ShowInfo(isBlack); &#125; &#125; else &#123; COORD pos = getMouseXY(RIGHT_CLICK); x = (pos.X - Left) / 2, y = pos.Y - Top; if (x &gt; 18 || x &lt; 0 || y &gt; 18 || y &lt; 0) continue; if (ChessBoard[x][y] == 0) &#123; PrintInXY(x * 2 + Left, y + Top, WhiteChess); ChessBoard[x][y] = WHITE; isBlack = !isBlack; ShowInfo(isBlack); &#125; &#125; Winner = CheckWin(x, y); if (Winner)break; &#125; while (true); Message(Winner);&#125;GameState CheckWin(int x, int y) &#123; int tmp = ChessBoard[x][y]; int num[4] = &#123; 1,1,1,1 &#125;; int i, j, m, n; for (i = 0; i &lt; 8; i++) &#123; m = x; n = y; j = i % 4; m += Direct[i][0]; n += Direct[i][1]; while (ChessBoard[m][n] == tmp) &#123; m += Direct[i][0]; n += Direct[i][1]; num[j]++; &#125; &#125; for (i = 0; i &lt; 4; i++) if (num[i] &gt;= 5) return tmp; return PLAYING;&#125;void Message(int whoWin) &#123; char * WhoWin; int x = 7 * 2 + Left, y = 9 + Top; char * str; str = "╔═════════╗"; PrintInXY(x - 6, y - 1, str); str = "║ ║"; PrintInXY(x - 6, y, str); str = "╚═════════╝"; PrintInXY(x - 6, y + 1, str); if (whoWin == BLACKWIN) &#123; WhoWin = "黑棋赢了"; PrintInXY(x, y, WhoWin); &#125; else &#123; WhoWin = "白棋赢了"; PrintInXY(x, y, WhoWin); &#125;&#125; 迷宫(随机生成)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;conio.h&gt;#include&lt;ctime&gt;#include&lt;Windows.h&gt;using namespace std;#define KEYDOWN(vk_code) ((GetAsyncKeyState(vk_code) &amp; 0x8000) ? 1 : 0)#define KEYUP(vk_code) ((GetAsyncKeyState(vk_code) &amp; 0x8000) ? 0 : 1)#define TOP 1#define LEFT (2 * TOP)#define MAX_SIZE 40#define RANDOM(min, max) ((min) + (rand()%((max) - (min) + 1)))#define ROAD 0#define WALL 1#define END 2typedef struct PlayerCharacter &#123; int x, y; char *PC; PlayerCharacter() &#123; PC = "●"; x = y = 1; &#125;&#125;PlayerCharacter;typedef struct RandomMap &#123; int **Map; int mapW, mapH; long mapID; RandomMap() &#123; mapW = 2 * RANDOM(8, MAX_SIZE / 2) + 1; mapH = 2 * RANDOM(5, MAX_SIZE / 2) + 1; Map = (int**)malloc(mapH * sizeof(int*)); for (int i = 0; i &lt; mapH; i++) &#123; Map[i] = (int*)malloc(mapW * sizeof(int)); for (int j = 0; j &lt; mapW; j++) Map[i][j] = WALL; &#125; &#125;&#125;RandomMap;void GotoXY(short x, short y);//光标移动void HideCursor();void Create(RandomMap rMap, int m, int n);void InitMap(RandomMap rMap);void PaintMapPoint(RandomMap rMap, int x, int y);void GamePlaying(PlayerCharacter &amp;pc);void PaintPC(PlayerCharacter pc);void Move(RandomMap rMap, PlayerCharacter &amp;pc, int x, int y);int main() &#123; SYSTEMTIME sys[2]; system("MODE con: COLS=120 LINES=50"); srand((unsigned int)time(0)); HideCursor(); PlayerCharacter pc; GetLocalTime(&amp;sys[0]); GamePlaying(pc); GetLocalTime(&amp;sys[1]); int mm = sys[1].wMinute - sys[0].wMinute, ss = sys[1].wSecond - sys[0].wSecond; if (ss &lt; 0) &#123; ss += 60; mm -= 1; &#125; else if (ss &gt; 59) &#123; ss -= 60; mm += 1; &#125; printf("\n好牛逼啊，走出迷宫只花了%2d:%2d的时间！\n", mm, ss); return 0;&#125;void GotoXY(short x, short y) &#123; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), &#123; x,y &#125;);&#125;void HideCursor() &#123; CONSOLE_CURSOR_INFO cursor_info = &#123; 1, 0 &#125;; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);&#125;bool CheckBorder(RandomMap rMap, int x, int y) &#123; if (x &lt;= 0 || y &lt;= 0 || x &gt;= rMap.mapW - 1 || y &gt;= rMap.mapH - 1)return true; else return false;&#125;bool CheckOutside(RandomMap rMap, int x, int y) &#123; if (x &lt; 0 || y &lt; 0 || x &gt; rMap.mapW - 1 || y &gt; rMap.mapH - 1)return false; else return true;&#125;void Create(RandomMap rMap, int m, int n) &#123; int next[4][2] = &#123; &#123; 0,1 &#125;, &#123; 1,0 &#125;, &#123; 0,-1 &#125;, &#123; -1,0 &#125; &#125;; int i, j, t; for (i = 0; i&lt;4; i++) &#123; j = rand() % 4; t = next[i][0], next[i][0] = next[j][0], next[j][0] = t; t = next[i][1], next[i][1] = next[j][1], next[j][1] = t; &#125; rMap.Map[m][n] = ROAD; for (i = 0; i&lt;4; i++) if (!CheckBorder(rMap, n + 2 * next[i][1], m + 2 * next[i][0]) &amp;&amp; rMap.Map[m + 2 * next[i][0]][n + 2 * next[i][1]] == WALL) &#123; rMap.Map[m + next[i][0]][n + next[i][1]] = ROAD; Create(rMap, m + 2 * next[i][0], n + 2 * next[i][1]); &#125;&#125;void InitMap(RandomMap rMap) &#123; Create(rMap, 1, 1); rMap.Map[rMap.mapH - 2][rMap.mapW - 2] = END; for (int i = 0; i &lt; rMap.mapW; i++) &#123; for (int j = 0; j &lt; rMap.mapH; j++) &#123; PaintMapPoint(rMap, i, j); &#125; &#125;&#125;void PaintMapPoint(RandomMap rMap, int x, int y) &#123; GotoXY(x * 2 + LEFT, y + TOP); switch (rMap.Map[y][x]) &#123; case 0: printf(" "); break; case 1: printf("※"); break; case 2: printf(" E"); break; &#125;&#125;void PaintPC(PlayerCharacter pc) &#123; GotoXY(pc.x * 2 + LEFT, pc.y + TOP); printf("%s", pc.PC);&#125;void Move(RandomMap rMap, PlayerCharacter &amp;pc, int x, int y) &#123; PaintMapPoint(rMap, pc.x, pc.y); pc.x += x; pc.y += y; PaintPC(pc);&#125;void GamePlaying(PlayerCharacter &amp;pc) &#123; RandomMap rm; InitMap(rm); PaintPC(pc); int x, y; while (pc.x != rm.mapW - 2 || pc.y != rm.mapH - 2) &#123; x = 0; y = 0; if (KEYDOWN(VK_UP)) &#123; y--; &#125; if (KEYDOWN(VK_DOWN)) &#123; y++; &#125; if (KEYDOWN(VK_LEFT)) &#123; x--; &#125; if (KEYDOWN(VK_RIGHT)) &#123; x++; &#125; if (x || y) if (CheckOutside(rm, pc.x + x, pc.y + y) &amp;&amp; rm.Map[pc.y + y][pc.x + x] != WALL) &#123; Move(rm, pc, x, y); &#125; Sleep(100); &#125; GotoXY(LEFT, rm.mapH + TOP);&#125; 贪吃蛇 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217#include &lt;Windows.h&gt;#include &lt;iostream&gt;#include &lt;ctime&gt;#include &lt;conio.h&gt;#include &lt;cstdlib&gt;using namespace std;#define KEYDOWN(vk_code) ((GetAsyncKeyState(vk_code) &amp; 0x8000) ? 1 : 0)#define KEYUP(vk_code) ((GetAsyncKeyState(vk_code) &amp; 0x8000) ? 0 : 1)#define RANDOM(min, max) ((min) + (rand()%((max) - (min) + 1)))#define MAP_SIZE 20#define TOP 1#define LEFT (TOP * 2)#define WIN 1#define LOSE -1#define GAMING 0//-------------贪吃蛇自身结构---------typedef struct Position &#123; int x; int y; Position operator+(Position op) &#123; return&#123; x + op.x,y + op.y &#125;; &#125; Position operator-(Position op) &#123; return&#123; x - op.x,y - op.y &#125;; &#125; bool operator!=(Position op) &#123; return (x != op.x || y != op.y); &#125; Position(int i = 0, int j = 0) &#123; x = i; y = j; &#125;&#125;Position, Direction;typedef struct SnakeNode &#123; SnakeNode* next; SnakeNode* prev; Position pos; Direction dir;&#125;*SnakeBody;typedef struct Snake &#123; SnakeBody head, tail; int length; Snake() &#123; length = 8; head = new SnakeNode(); SnakeBody q = head; for (int i = 0; i &lt; length; i++) &#123; SnakeBody p = new SnakeNode(); p-&gt;pos = &#123; 0 , length - i - 1 &#125;; p-&gt;dir.x = 0; p-&gt;dir.y = 1; p-&gt;prev = NULL; if (i == 0) &#123; q = head = p; &#125; else &#123; p-&gt;prev = q; q-&gt;next = p; q = q-&gt;next; &#125; &#125; tail = q; tail-&gt;next = NULL; &#125;&#125;Snake;int Map[MAP_SIZE][MAP_SIZE];//----------相关函数--------void GotoXY(short x, short y);//光标移动void HideCursor();//隐藏光标void Gaming();int main() &#123; system("MODE con: COLS=50 LINES=22"); srand((unsigned int)time(0)); HideCursor(); Gaming(); return 0;&#125;void GotoXY(short x, short y) &#123; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), &#123; x,y &#125;);&#125;void HideCursor() &#123; CONSOLE_CURSOR_INFO cursor_info = &#123; 1, 0 &#125;; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);&#125;void MoveSnake(Snake &amp;S) &#123; SnakeBody p = S.head; while (p) &#123; if (!p-&gt;next) Map[p-&gt;pos.y][p-&gt;pos.x] = 0; if (p == S.head) Map[p-&gt;pos.y][p-&gt;pos.x] = 1; p-&gt;pos = p-&gt;pos + p-&gt;dir; p = p-&gt;next; &#125; Map[S.head-&gt;pos.y][S.head-&gt;pos.x] = 2;&#125;void PaintSnake(Snake &amp;S) &#123; SnakeBody p = S.head; Position q; while (p) &#123; q = p-&gt;pos - p-&gt;dir; GotoXY(2 * q.x + LEFT, q.y + TOP); printf(" "); p = p-&gt;next; &#125; p = S.head; while (p) &#123; q = p-&gt;pos; GotoXY(2 * q.x + LEFT, q.y + TOP); printf("□"); p = p-&gt;next; &#125; GotoXY(2 * S.head-&gt;pos.x + LEFT, S.head-&gt;pos.y + TOP); printf("○");&#125;void CreateFood() &#123; int x, y; do &#123; x = RANDOM(1, MAP_SIZE - 1); y = RANDOM(1, MAP_SIZE - 1); &#125; while (Map[y][x] != 0); Map[y][x] = 3; GotoXY(LEFT + 2 * x, TOP + y); printf("★");&#125;void Gaming() &#123; for (int i = -1; i &lt;= MAP_SIZE; i++) &#123; GotoXY(LEFT + 2 * i, 0); printf("※"); GotoXY(LEFT + 2 * i, TOP + MAP_SIZE); printf("※"); &#125; for (int i = -1; i &lt;= MAP_SIZE; i++) &#123; GotoXY(0, TOP + i); printf("※"); GotoXY(LEFT + 2 * MAP_SIZE, TOP + i); printf("※"); &#125; Snake snake; Direction nowD = &#123; 0,1 &#125;; for (int i = 0; i &lt; MAP_SIZE; i++) for (int j = 0; j &lt; MAP_SIZE; j++) Map[i][j] = 0; SnakeBody p = snake.head; while (p) &#123; GotoXY(LEFT + 2 * p-&gt;pos.x, TOP + p-&gt;pos.y); if(p == snake.head) printf("○"); else printf("□"); p = p-&gt;next; &#125; p = snake.head; while (p) &#123; if(p == snake.head)Map[p-&gt;pos.y][p-&gt;pos.x] = 2; else Map[p-&gt;pos.y][p-&gt;pos.x] = 1; p = p-&gt;next; &#125; CreateFood(); bool win = false; while (true) &#123; if (_kbhit()) &#123; if (KEYDOWN(VK_UP)) &#123; if (nowD != Direction(0,1)) nowD = &#123; 0,-1 &#125;; &#125; if (KEYDOWN(VK_DOWN)) &#123; if (nowD != Direction(0, -1)) nowD = &#123; 0,1 &#125;; &#125; if (KEYDOWN(VK_LEFT)) &#123; if (nowD != Direction(1, 0)) nowD = &#123; -1,0 &#125;; &#125; if (KEYDOWN(VK_RIGHT)) &#123; if (nowD != Direction(-1, 0)) nowD = &#123; 1,0 &#125;; &#125; &#125; snake.head-&gt;dir = nowD; for (SnakeBody p = snake.head-&gt;next;p; p = p-&gt;next) &#123; p-&gt;dir = p-&gt;prev-&gt;pos - p-&gt;pos; &#125; if (Map[snake.head-&gt;pos.y + snake.head-&gt;dir.y][snake.head-&gt;pos.x + snake.head-&gt;dir.x] == 1) &#123; break; &#125; if (Map[snake.head-&gt;pos.y + snake.head-&gt;dir.y][snake.head-&gt;pos.x + snake.head-&gt;dir.x] == 3) &#123; SnakeBody q = new SnakeNode(); q-&gt;dir = snake.tail-&gt;dir; q-&gt;pos = snake.tail-&gt;pos - snake.tail-&gt;dir; q-&gt;next = NULL; q-&gt;prev = snake.tail; snake.tail-&gt;next = q; snake.tail = q; snake.length++; Map[q-&gt;pos.y][q-&gt;pos.x] = 1; CreateFood(); &#125; if (Map[snake.head-&gt;pos.y][snake.head-&gt;pos.x] == 1) &#123; break; &#125; MoveSnake(snake); PaintSnake(snake); if (snake.length == MAP_SIZE * MAP_SIZE - 1) &#123; win = true; break; &#125; if (snake.head-&gt;pos.x &lt; 0 || snake.head-&gt;pos.x &gt;= MAP_SIZE || snake.head-&gt;pos.y &lt; 0 || snake.head-&gt;pos.y &gt;= MAP_SIZE) &#123; break; &#125; Sleep(200); &#125;&#125;]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小小的灵感]]></title>
    <url>%2F2017%2F06%2F27%2F%E5%B0%8F%E5%B0%8F%E7%9A%84%E7%81%B5%E6%84%9F%2F</url>
    <content type="text"><![CDATA[灵感来源最近在玩一款名为“[放置江湖][1]”的文字武侠类游戏，游戏中的武侠人物与武功大多来源于金庸大师的武侠作品。但是由于不同门派之间严重不平衡，影响了大多玩家的游戏体验，因此我希望能模仿这款“[放置江湖][1]”游戏，先制作一款简单的单机文字类游戏。 游戏设计游戏类型及背景 放置类 洪荒背景 人物设计 人物基本设定人类，每个人都能修炼，可以往不同方向发展妖族，分有不同种类，发展方向不同，主修巫族，主要修炼肉体以及天生法则 人物主属性 根骨(10~20):影响技能的学习要求 悟性(10~20):某些技能的学习需要 气运(10~20):影响获得的物品的品质此三项为隐藏属性，初始属性总和为50 力量(5~20):力量代表人物肌肉强度与力气大小。 敏捷(5~20):敏捷代表人物手眼协调、肢体灵活、反应与平衡能力。 体质(5~20):体质代表人物的健康状况与耐力。 智力(5~20):智力代表人物的学习与思考能力。此四项属性总和不定，调整值：((属性值-11)/2)的上行取整 人物能力属性 攻击力:直接的伤害力度，不同技能会带上不同的额外伤害 防御力:直接的防御能力，不同的防御技能会带来额外的防御或特殊的防御能力 命中:减低敌方闪避效果 闪避:闪避成功时完全避免伤害 格挡:格挡成功时对直接伤害的有一定量消弱 攻击速度:决定了人物的出手速度 人物衍生属性 气血/生命值:生命值归零时，人物死亡 法力/能量值:人物使用技能时消耗 精神值:人物学习时消耗 年龄:能决定人物的以上三种属性 经验:能决定人物的以上三种属性 等级:能决定人物的以上三种属性 人物附属属性 功德值/业力值:由人物平时的行动决定，会影响某些技能的效果 威望:影响NPC对人物的看法与评价 魅力值:影响NPC对人物的初始好感度 缘分:无 师父:教你功法的人 转生次数:转生轮回次数 人物消耗值 灵石:最普通的消耗品 师门贡献:购买门派特殊技能的消耗 精气神:学习升级技能的消耗 门派(总共有9个门派，6个基础门派+3个隐藏门派) 人教(太上老君) 基本技能： 师父选择及拜师条件： 阐教(元始天尊) 基本技能： 师父选择及拜师条件： 截教(通天教主) 基本技能： 师父选择及拜师条件： 天庭(女娲) 基本技能： 师父选择及拜师条件： 地府(后土) 基本技能： 师父选择及拜师条件： 佛教(接引、准提) 基本技能： 师父选择及拜师条件： 紫霄宫(鸿钧) 基本技能： 技能 技能 师父选择及拜师条件：该门派只能拜师鸿钧拜师条件:第xx章鸿钧成圣，通过混沌(防御力&gt;=n)，找到鸿钧(气运20，悟性20) 五庄观(镇元子、) 基本技能： 师父选择及拜师条件：该门派只能拜师镇元子拜师条件:第xx章鸿钧成圣，通过混沌(防御力&gt;=n)，找到鸿钧(气运20，悟性20) 魔教(罗睺) 基本技能： 师父选择及拜师条件：该门派只能拜师罗睺拜师条件:第xx章鸿钧成圣，通过混沌(防御力&gt;=n)，找到鸿钧(根骨20，悟性20) 章节设计(总共111个章节) 盘古开天 龙汉初劫]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客配置]]></title>
    <url>%2F2017%2F06%2F27%2F%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[刚刚弄好GitHub和Hexo，这时就简单介绍下博客配置的方法 第一步：安装Git官网下载，正常安装，在Windows命令行下输入git –version检查版本配置Git个人信息 12git config --global user.name &quot;名字&quot;git config --global user.email &quot;邮箱，最好是你的注册邮箱&quot; 第二步：安装Node.js同样官网下载，正常安装，在Windows命令行下输入node -v和npm -v检查版本编辑系统环境变量path的值，追加nodejs的安装目录以管理员打开cmd命令窗口，执行命令 1234npm install -g expressnpm install -g express-generatorcd C:\Program Files\nodejs //改成对应的安装目录express -t ejs newsproject 如果安装下载速度较慢，请尝试使用npm淘宝镜像npm config set registry https://registry.npm.taobao.org 第三步：安装Hexo命令行下输入一下命令进行全局安装 1npm install hexo-cli -g 第四步：创建Github项目注册Github账号，创建Github项目，命名为用户名/用户名.github.io 第五步：本地搭建在自己的电脑中找一个地方新建文件夹——就是你本地保存博客文件的地方，最好是纯英文目录在博客目录文件夹右键Git Bash Here 12hexo init // 创建一个hexo模板npm install // 安装依赖包 第六步：部署博客获取密钥并配置执行以下命令获取密钥，密钥所在目录为(C:/Users/username/.ssh/id_rsa.pub)：ssh-keygen -t rsa -C &quot;your_email@example.com&quot; // 一直回车直至密钥生成成功然后打开GitHub的设置，在其中选择”SSH and GPG keys”，然后点击添加SSH密钥，Title值随意设定，Key值则是刚刚所说的id_rsa.pub文件当中的全部内容点击确定，随后等待十分钟左右（没办法，GitHub服务器在国外，链接速度不快）在命令行下执行命令ssh ‐T git@github.com测试SSH key是否添加成功，若出现下面情况，说明SSH key添加成功。 12The authenticity of host &apos;github.com (xxx.xx.xxx.xxx)&apos; can&apos;t be established. RSA key fingerprint is xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx Are you sure you want to continue connecting (yes/no)? yes // 输入yesHi username! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 配置博客修改配置文件 1234deploy: type: git repo: git@github.com:username/username.github.io.git branch: master 部署博客为了完成部署，我们需要安装hexo-deployer-git工具。 12npm install hexo-deployer-git --save // 安装hexo d -g // 生成和部署 第七步：美化大家可以在网络上找到很多不同的主题，官网主题，知乎主题等等不过本人比较喜欢Next的简洁风格，因此写下Next主题的安装方法：在博客目录文件夹右键Git Bash Here执行命令git clone https://github.com/iissnan/hexo-theme-next themes/next大家可以按照喜好进行配置，也可以在网络上找相应的设置方法，个人有个人喜好 第八步：开始你的第一篇博客吧Hexo的博客文章保存在博客目录底下的\source\_post目录中，把当中的HelloWorld.md删除，然后再博客目录下右键Git Bash Here输入hexo new &quot;第一篇博客名字&quot;就会在\source\_post目录下创建新的博客文章 参考资料:1. Hexo之NexT主题搭建博客详细过程2. Hexo命令：Hexo有很多命令，在这里总结一下一些常用命令： 命令名称 命令简写 命令含义 hexo generate 简写：hexo g 生成静态文件，会在当前目录下生成一个public文件夹 hexo server 简写：hexo s 启动本地服务，用于博客的预览 hexo deploy 简写：hexo d 部署到远程（如GitHub，可以在_config.yml中配置） hexo new post-name 简写：hexo n post-name 新建文章 hexo new page page-name 简写：hexo n page page-name 新建页面 常用的组合命令：hexo d -g // 生成和部署hexo s -g // 生成和预览 3. Markdown常用语法参考 见Cmd Markdown 编辑阅读器 - 作业部落出品]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2017%2F06%2F26%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[刚刚弄好GitHub和Hexo，这是具有纪念性质的第一篇博客 为什么开始写博客 记录学习的小细节对于复杂的编程算法，每一个小细节都可能决定最后的结果 储存代码方便以后的回忆 记录灵感每一丝灵感的闪现都来之不易，只有记录下来才可能产生最终的结果 为什么使用GitHub GitHub是免费的在最开始准备写博客的时候，我考虑过自己搭建网站，但是高昂的空间租赁费用让我望而却步。后来，在逛知乎的时候，发现很多人都在推荐GitHub，于是就上网搜索了GitHub。就冲着GitHb的免费使用，我就决定选择GitHub了。 MarkDown语法简单易明GitHub中的博客页面采用的是MarkDown语法，简单易学，容易上手，不用费太多额外的功夫在博客页面的编写上。 大量开源的Blog模板在GitHub上就有许多能直接使用的开源博客模板，节省了大量在页面设计方面的时间。 结束语 感谢网络上所有用心做教程的人，点击这里去往教程：Hexo之NexT主题搭建博客详细过程。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
